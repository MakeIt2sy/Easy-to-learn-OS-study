# CHAPTER 01 운영체제의 개요

# 운영체제 소개

## 운영체제의 정의

운영체제는 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어이다.

## 운영체제의 역할과 목표

| 운영체제의 역할 |
| --- |
| 자원 관리 |
| 자원 보호 |
| 하드웨어 인터페이스 제공 |
| 사용자 인터페이스 제공 |

| 운영체제의 목표 |
| --- |
| 효율성 |
| 안정성 |
| 확장성 |
| 편리성 |

<br>

### 운영체제의 역할

- 자원 관리: 컴퓨터 자원(CPU, RAM, 키보드 등)을 응용 프로그램에게 배분하고 적절한 시점에 회수하여, 사용자가 원활하게 작업할 수 있도록 한다.
- 자원 보호: 비정상적인 작업으로부터 컴퓨터 자원을 지킨다. 응용 프로그램이 자신에게 할당되지 않은 다른 프로그램(다른 응용 프로그램, 커널 등)의 영역을 침범할 수 있다면, 다른 사람의 작업을 망치거나 데이터를 지우게 되는 경우가 발생할 수 있기 때문이다.
- 하드웨어 인터페이스 제공: CPU, RAM, 키보드, 마우스와 같은 다양한 하드웨어를 일관된 방법으로 사용할 수 있도록 지원한다. 이는 드라이버를 컴퓨터에 설치해야 가능하다. 드라이버는 기본적으로 운영체제를 설치할 때 자동 설치되지만, 일부 하드웨어 드라이버의 경우 유저가 개별적으로 설치해야 한다.
- 사용자 인터페이스 제공: 유저가 운영체제를 편리하게 사용할 수 있도록 지원하는 인터페이스이다. GUI가 이에 해당된다.

<br>

### 운영체제의 목표

- 효율성: 운영체제의 목표는 자원을 효율적으로 관리하는 것이다. 같은 자원을 사용하여 더 많은 작업량을 처리하거나, 같은 작업량을 처리하는 데 보다 적은 자원을 사용하는 것이다.
- 안정성: 운영체제는 하드웨어 전체를 관리하는 소프트웨어이고, 유저와 응용 프로그램의 작업은 운영체제 위에서 일어난다. 따라서 운영체제가 불안정하면 모든 작업이 불안정해지기 때문에 운영체제는 안정성이 담보되어야 한다.
- 확장성: 운영체제는 다양한 시스템 자원을 추가하거나 제거하기에 편리해야 한다. 구체적인 예로, 운영체제는 하드웨어의 종류에 상관없이 꽂으면 바로 실행할 수 있는 플러그 앤드 플레이 기능을 제공해야 한다. 또한 앞으로 개발될 하드웨어의 확장성을 보장하기 위해 유저의 편리성뿐만 아니라 하드웨어 제작자의 편리성도 고려해야 한다.
- 편리성: 유저가 편리하게 작업할 수 있는 환경을 제공하는 것이다. 그 예로, 운영체제가 효율성과 컴퓨터의 속도를 포기하고, 유저에게 GUI를 지원하는 것이 있다. 운영체제는 응용 프로그램과 사용자에게 다양한 편리성을 제공하면서도 자원의 낭비 요소를 막아야 한다.

<br>

# 운영체제의 구조

![운영체제의 구조를 간략하게 표현한 그림](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/81b5c3d9-4d02-4d9e-a276-23bdc5b71d23/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C_%EA%B5%AC%EC%A1%B0.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221231%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221231T121512Z&X-Amz-Expires=86400&X-Amz-Signature=037615d1f270d683551da31814e5ae172713a2064a44ecab1ba0c28338fefb9b&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C_%25EA%25B5%25AC%25EC%25A1%25B0.png%22&x-id=GetObject)

운영체제의 구조를 간략하게 표현한 그림

<br>

운영체제는 크게 인터페이스와 커널로 나뉜다. 인터페이스는 커널에 명령을 전달하고 실행 결과를 사용자와 응용 프로그램에 돌려주는 역할을 한다. 커널에는 운영체제의 핵심 기능이 담겨있다.

<br>

### 인터페이스가 하는 일

유저는 커널에 직접 접근하지 않고 인터페이스를 통해 System Call을 해 커널에 접근한다. 

<br>

### 커널이 하는 일

커널은 프로세스 관리, 메모리 관리, 파일 시스템 관리, 입출력 관리, 프로세스 간 통신 관리 등 운영체제의 핵심 기능을 한다.

<br>

### 드라이버

하드웨어 제작자가 만드는 소프트웨어이다. 커널에 모든 하드웨어에 맞는 인터페이스를 다 개발하여 삽입하기 힘들기 때문에, 커널은 입출력의 기본적인 부분만 제작하고, 하드웨어의 특성을 반영하는 소프트웨어인 드라이버를 하드웨어 제작자가 만든다.

커널-하드웨어는 드라이버에 따라 직접 연결(커널이 제공하는 드라이버일 경우)되기도 하고 하드웨어 제작자가 제공하는 드라이버를 통해 연결(하드웨어 제작자가 제공하는 드라이버일 경우)되기도 한다.

<br>

### printf(”Hello, world”); 가 실행되는 과정

1. 인터페이스로 System Call을 요청한다.
2. device driver에서 인터럽트를 발생시킨다.
3. 콘솔에서 출력된다.

<br>

## 커널의 종류

### 단일형 구조 커널

초창기 운영체제의 구조이며, 커널의 핵심 기능을 구현하는 모듈들이 구분 없이 하나로 구성되어 있다. MS-DOS, VMS, 초기의 유닉스가 이에 속한다. 초기의 운영체제는 기능을 구현하기에 바빠 모듈을 분리하여 구현할 만한 여력이 없었다.

다른 함수를 만들지 않고 main 함수에 모든 코드를 넣은 C 프로그램과 비슷하다.

### 장점

- 모듈 간의 통신 비용이 줄어들어 효율적인 운영이 가능하다.

### 단점

- 버그나 오류를 처리하기 어렵다.
- 운영체제의 여러 기능이 서로 연결되어 있어 상호 의존성이 높아져 기능상의 작은 결함이 시스템 전체로 확산되기 쉽다.
- 수정이 어려워 이식성이 낮아, 다양한 환경의 시스템에 적용하기 어렵다.

요약하자면 통신 비용을 줄여 효율적인 운영이 가능하긴 하지만, 유지보수가 어렵다는 단점이 있다. 현대의 운영체제는 매우 크고 복잡하기 때문에 완전 단일형 구조의 운영체제를 구현하기 어렵다.

<br>

### 계층형 구조 커널

단일형 구조 커널이 발전된 형태로, 비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만들고 계층 간의 통신을 통해 운영체제를 구현하는 방식이다. 마이크로소프트의 윈도우즈를 비롯한 오늘날의 운영체제는 대부분 계층형 구조 커널로 이루어져 있다.

### 장점

- 비슷한 기능을 모아 모듈화하여 단일형 구조보다 버그나 오류를 쉽게 처리할 수 있다. 오류가 발생했을 때 전체 커널을 고치는 대신 해당 계층만 따로 수정할 수 있어 디버깅하기 쉽다.

<br>

### 마이크로 구조 커널

기존의 계층형 구조 커널의 경우, 다양한 하드웨어와 유저의 요구를 수용하기 위해 계속 계층과 기능을 추가하여 커널의 크기가 커지고 그에 따라 필요한 하드웨어의 용량이 늘어났다. 또한 커널 소스가 방대해짐에 따라 오류를 잡기가 어려워졌다. 마이크로 구조 커널은 이러한 계층형 구조의 접근 방식과 반대로 개발된 커널이다.

마이크로 구조 커널의 운영체제는 프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 가장 기본적인 기능만 제공한다. 다른 커널 구조에 비해 운영체제의 많은 부분이 사용자 영역에 구현되어 있다. 커널은 메모리 관리와 프로세스 간의 동기화 서비스를 제공하며, 메모리 관리자와 동기화 모듈은 프로세스 간 통신 모듈로 연결되어 있다.

각 모듈은 세분화되어 존재하고, 독립적으로 작동한다. 이 때문에 하나의 모듈이 실패하더라도 전체 운영체제가 멈추지는 않는다. 또한 많은 컴퓨터에 이식하기 쉽고, 커널이 가벼워 CPU 용량이 작은 시스템에도 적용이 가능하다. 이 구조에서 모듈 간의 정보 교환은 프로세스 간 통신을 이용하여 이루어진다.

대표적인 예로 마하가 있으며, 마하는 OS X와 iOS의 커널로 사용되었다.

<br>

## 가상머신

C 언어 같은 경우 다른 커널을 가진 운영체제와의 호환성이 떨어진다. 어떤 운영체제에서 작성한 C 프로그램은 다른 계열의 운영체제나 다른 버전의 운영체제에서는 작동하지 않는다. Java 같은 경우 JVM이라는 가상 머신을 도입하여 이러한 호환성 문제를 해결했다. Java는 운영체제 위에 가상머신을 만들고 그 위에서 응용 프로그램이 작동하게 한다. 이렇게 하면 개발자가 하나의 프로그램만 만들어 여러 운영체제에서 똑같이 실행할 수 있다. 대신 Java 프로그램을 실행하기 위해서 각 운영체제마다 각각 JVM을 설치해야 한다. 또한 가상머신을 활용하면 호환성은 높아지지만 속도가 느려진다.

<br>

# 운영체제의 역사

## 1940년대 - 초창기 컴퓨터

최초의 컴퓨터인 에니악이 개발되었다. 에니악은 진공관이 켜지면 1, 꺼지면 0이라고 판단하는 논리였고 이는 컴퓨터가 2진법을 사용하는 계기가 되었다.

<br>

## 1950년대 - 일괄 작업 시스템

진공관 대신 IC 칩을 사용하는 현대적인 모습의 컴퓨터가 탄생했다. 운영체제, CPU, 메인 메모리가 존재했으나, 천공카드 리더를 입력장치로, 라인 프린터를 출력장치로 사용했다. 지금의 프로그램과 유사한 방식으로 다양한 소프트웨어를 개발할 수 있었다. 에니악 시절의 하드와이어링 시스템 대신 천공카드 리더를 입력장치로 사용했기 때문에, 프로그램만 바꾸면 다른 작업을 실행할 수 있었다. 지금의 프로그램 환경과 다르게 모든 작업을 한꺼번에 처리해야 하고 프로그램 실행 중간에 유저가 데이터를 입력하거나 수정하는 것이 불가능한 일괄 작업 시스템(일괄 처리 시스템)이었다.

운영체제가 존재하기 때문에 메인 메모리는 운영체제 영역과 유저 영역으로 나뉘어 있다.

<br>

## 1960년대 초반 - 대화형 시스템

기존의 일괄 작업 시스템은 프로그램과 데이터를 같이 입력하여 작업의 최종 결과를 얻는 것만 할 수 있었다. 하지만 키보드와 모니터가 등장함으로써 새롭게 탄생한 대화형 시스템에서는 작업 중간에, 새로운 값을 입력하거나, 기존의 데이터를 변경하거나, 중간 결과값을 보는 것이 가능해졌다. 이로 인해 문서 편집기, 게임 등의 다양한 응용 프로그램을 개발할 수 있게 되었다.

<br>

## 1960년대 후반 - 시분할 시스템

이 시기의 컴퓨터는 크기가 작아지고 계산 능력이 향상되었으나 허가받은 소수만 사용할 수 있었고 고가였다. 값비싼 컴퓨터로 1번에 하나의 작업만 수행하는 것을 보다 효율적으로 바꾸기 위해 다중 프로그래밍 기술이 개발되었다. 다중 프로그래밍은 하나의 CPU로 여러 작업을 동시에 수행하는 기술이다.

컴퓨터 내부에서 다중 프로그래밍 기술은 시분할 방식으로 구현된다. 이는 여러 작업을 아주 짧은 시간마다 바꿔가며 진행하는 방식이다. 이렇게 하면 유저는 여러 작업이 동시에 진행되는 듯한 착각에 빠질 수 있다. 시분할 시스템의 단점은 여러 작업을 동시에 처리하기 위한 추가 작업이 필요하다는 것과, 중요한 작업이 일정 시간 내에 끝나는 것을 보장하지 못한다는 것이다. 만약 로켓 발사같은 무조건 시간 내에 끝내야 하는 작업을 수행해야 한다면, 시분할 시스템 대신 실시간 시스템을 사용해야 한다.

<br>

## 1970년대 후반 - 분산 시스템

개인용 컴퓨터와 인터넷이 등장하면서 조성된 새로운 컴퓨팅 환경을 분산 시스템이라고 한다.

당시 사용하던 복잡한 계산이나 많은 양의 데이터를 처리하기 위해 사용한 메인프레임이라는 값비싼 대형 컴퓨터가 있었다. 그리고 PC와 인터넷이 보급되면서 값이 싸고 크기가 작은 컴퓨터들을 하나로 묶어 대형 컴퓨터에 버금가는 시스템을 만들었다. 분산 시스템은 네트워크상에 분산되어 있는 여러 컴퓨터로 작업을 처리하고 그 결과를 상호 교환한다.

<br>

## 1990년대부터 - 클라이언트/서버 시스템

분산 시스템의 경우 시스템에 참가하는 모든 컴퓨터가 동일한 지위이기 때문에 컴퓨터가 고장나거나 추가되면 작업을 분배하고 결과를 모으기 어렵다. 클라이언트/서버 시스템은 이러한 문제점을 해결하기 위한 기술로, 클라이언트와 거기에 응답하여 요청받은 작업을 처리하는 서버로 구성된다.

웹 시스템이 대표적인 클라이언트/서버 시스템의 예이다. 클라이언트/서버 시스템에서 서버는 멈추지 않고 계속 작동하면서 클라이언트의 요청을 처리한다. 서버에는 멈추지 않고 계속 작동하는 프로그램인 데몬이 있으며, 웹 데몬의 역할을 하는 프로그램으로 아파치 톰캣, IIS가 있다.

<br>

## 2000년대 초반부터 - P2P 시스템

기존의 클라이언트/서버 구조로 대용량 파일 공유 시스템을 구현하면 서버 과부하가 일어난다. P2P 시스템은 서버 부하를 줄이기 위한 새로운 시스템으로, 서버를 거치지 않고 사용자와 사용자를 직접 연결한다. 이 시스템에서는 서버가 파일 검색만 맡고 실제 파일 전송은 사용자끼리 하기 때문에 서버 부하가 적다.

<br>

## 그리드 컴퓨팅

필요한 컴퓨팅 자원을 구매하여 사용하는 컴퓨팅 환경이다. 일반인 대상 시스템이라기보다는 연구용이나 상업용으로 이용된다.

<br>

## 클라우드 컴퓨팅

언제 어디서나 응용 프로그램과 데이터를 자유롭게 사용할 수 있는 컴퓨팅 환경으로 그리드 컴퓨팅과 SaaS를 합쳐놓은 형태이다. 하드웨어를 포함한 시스템이 구름에 가려진 것처럼 사용자에게 보이지 않는 컴퓨팅 환경이라는 의미에서 클라우드라는 명칭이 붙었다.

예를 들어 클라우드 서버에 홈페이지를 올려놓고 사용한 만큼 비용을 지불하는 것이 있다. 이 경우 서버와 네트워크 관리도 클라우드 서버 제공자가 알아서 해준다.

<br>

## 사물 인터넷

사물에 센서와 통신 기능을 내장하여 인터넷에 연결하는 기술이다. 인터넷으로 연결된 사물들이 서로 데이터를 주고받아 스스로 분석하고 학습한 정보를 유저에게 제공하거나, 그 정보를 기반으로 새로운 서비스를 창출한다.