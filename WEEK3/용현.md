
#   Q&A:

-   스케줄링은 언제 발생하나요? (CPU 스케줄링 시점)
-   다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)에 대해 설명

---
#   스케쥴러

프로세스를 스케줄링하기 위한 스케줄러는 크게 세가지 종류가 존재한다

##  High level 스케쥴러

-   시스템 내 전체 작업수를 조절한다
-   메모리는 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리에 임시로 저장한다

##  Low level 스케쥴러

-   CPU와 메모리 사이의 스케줄링을 담당한다
-   준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬 건지 결정한다
-   프로세스에 CPU를 할당한다( `dispatch` )
  
##  Middle Level 스케쥴러

-   메모리 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다
-   프로세스에게서 메모리 공간을 해제한다
-   현 시스템에서 메모리에 너무 많은 프로그램이 동싱에 올라가는 것을 조절한다

---

#   스케줄링 시 고려사항

-   공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 한다
-   효율성: 시스템 자원이 유휴 시간 없이 사용되도록 배정해야 한다
-   안정성: 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호애햐 한다
-   확장성: 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치해야한다
-   반응시간보장
-   무한연기 방지

---

#   스케줄링 

-   선점형
    -   실행 상태에 있는 작업을 OS 중단시키고 새로운 작업을 실행할 수 있다.
    -   문맥교환이 추가되어 낭비가 발생한다
    -   하나의 프로세스가 CPU를 독점할 수 없기 때문에 빠른 응답 시간을 요구하는 시분할 시스템에 적합하다
    -   대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용한다.
-   비선점형
    -   실행 상태에 있는 작업이 완료될때까지 다른 작업을 실행할 수 없다.
    -   시스템 처리율이 떨어진다.


---

#   스케줄링 알고리즘

스케줄링 대상은 준비 큐에서 대기하고 있는 프로세스들.
알고리즘 성능측정은 주로 프로세스들의 평균 대기시간으로 측정한다. 평균 대기시간이 길수록 성능이 안좋은 알고리즘으로 측정한다.

##  비선점형

### FCFS(First Come First Served)

-   먼저 온 순서대로 CPU를 할당
-   CPU를 잡으면 작업이 끝날때까지 CPU를 반환하지 않는다 -> Convoy Effect 발생

> Convoy Effect
> 처리시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스의 대기 시간이 길어지는 것

### SJF(Shortest Job First)

-   준비큐에 있는 프로세스 중에서 실행시간(cpu burst)이 가장 짧은 Job부터 CPU를 할당
-   다른 프로세스가 먼저 도착하여도 실행시간이 짧은 프로세스에게 먼저 할당 -> Starvation 발생
-   OS가 작업 시간을 측정하기 어렵다.

> Starvation
> 우선순위에 밀려서 CPU를 할당받지 못하는 경우

### HRN(Highest Response Ratio Next)

-   우선순위 = (대기시간 + CPU 사용시간) / CPU 사용시간
-   우선순위를 정할 때 대기 시간을 고려함으로써 아사현상을 완화시킬 수 있지만 해결은 하지 못한다.


##  선점형

### RR(Round Robin)
-   현대적인 CPU 스케쥴링
-   각 프로세스는 동일한 크기의 시간(time slice)를 할당받는다
-   할당시간이 지나면 프로세스는 선점당하고, 준비 큐의 제일 뒤로 가서 기다린다
-   타임 슬라이스의 크기에 따라 성능이 영향을 받는다
    -   타임 슬라이스가 너무 큰 경우: FCFS 스케줄링과 다를게 없어진다 -> Convoy Effect 발생
    -   너무 작은 경우: 문맥교환으로 인한 오버헤드 발생한다.

### SRT(Shortest Remaining Time)
-   SJF와 RR을 혼합한 방식
-   남은 작업 시간이 적은 프로세스를 먼저 할당한다
-   프로세스의 남은 시간을 주기적으로 계산해야하므로 작업이 추가된다
-   프로세스의 종료 시간을 예측하기도 어렵고, Starvation 발생하므로 잘 사용하지 않는다.

### Priority Scheduling
- 우선순위가 가장 높은 프로세스에게 CPU를 할당한다
- Starvation이 발생할 수 있다.
  
### Multi-level Queue Scheduling
-   우선순위에 따라 준비큐를 여러개 사용하는 방식이다
-   프로세스는 OS로 부터 받은 우선순위에 따라 해당 우선순위의 큐에 삽입된다
-   각각의 큐는 RR 방식으로 동작하고, 우선순위에 따라 각각의 큐에 다양한 방식의 스케줄링이 가능하다(ex: 큐마다 타임슬라이스를 다르게 한다.)
-   우선순위는 고정형 우선순위를 사용한다
-   상단의 큐에 있는 모든 프로세스가 작업이 끝나야 다음 우선순위 큐의 작업이 시작되므로, 우선순위가 낮은 프로세스의 작업은 연기된다.

### Multi-level Feedback Queue Scheduling
-   각각의 큐에 RR을 사용하되, CPU를 사용하고 나면 프로세스의 우선순위가 낮아진다
-   CPU를 한번씩 할당받아 실행될때마다 우선쉰아가 낮아지고, CPU 사용이 끝나면 원래의 큐로 돌아가지 않고, 우선순위가 하나 낮은 큐의 끝으로 돌아간다
-   우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화한다
-   프로세스의 우선순위가 낮아질수록, CPU를 할당받는 주기가 적어지므로, 우선순위가 낮은 프로세스의 큐는 타임슬라이스를 크게 설정하여 어렵게 얻은 CPU를 좀더 오랫동안 사용하게 할 수 있게 한다

> 유닉스 운영체제
> 타임슬라이스를 고정하지 않고, 10~200millis로 조정할 수 있는 이유도 다단계 피드백 큐 스케줄링을 사용하기 때문이다.
  


---

Q. 스케줄링은 언제 발생하나요? (CPU 스케줄링 시점)

A.  크게 4개의 시점에서 발생합니다. 

running -> waiting 시점은 보통 I/O 요청이 일어나거나 자식 프로세스가 종료 대기를 할 때 입니다.
running -> ready 시점은 인터럽트(Interrupt) 가 발생했을 때 입니다.
waiting -> ready 시점은 I/O가 완료되었을 때 입니다.
running -> terminate 시점은 프로세스가 완전히 종료되었을 때 입니다.