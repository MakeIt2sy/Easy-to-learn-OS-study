# CHAPTER 05 프로세스 동기화

# 프로세스 간 통신

- 프로세스가 다른 프로세스와 데이터를 주고받는 것
- IPC라고도 한다.
- 컴퓨터 내에 있는 프로세스뿐 아니라 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와의 통신도 포함된다.
- 읽기와 쓰기 연산으로 구현한다.

## 데이터의 위치에 따른 분류

### 프로세스 내부 데이터 통신

하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우, 프로세스 내부의 스레드는 전역 변수나 파일을 이용하여 데이터를 주고 받는다.

### 같은 컴퓨터에 있는 프로세스 간 데이터 통신

같은 컴퓨터에 있는 여러 프로세스끼리 통신하는 경우, 공용 파일 또는 운영체제가 제공하는 파이프를 사용하여 통신한다.

### 네트워크를 이용한 데이터 통신

여러 컴퓨터가 네트워크에 연결되어 있을 경우, 소켓을 이용하여 통신한다.

## 통신 방향에 따른 분류

### 양방향 통신

데이터를 동시에 양쪽 방향으로 전송할 수 있다. 소켓 통신이 이에 해당한다.

### 반양방향 통신

데이터를 양쪽 방향으로 전송할 수 있지만, 동시 전송은 불가능하고, 특정 시점에 한쪽 방향으로만 전송할 수 있다. 무전기가 이에 해당한다.

### 단방향 통신

한쪽 방향으로만 데이터를 전송할 수 있는 구조이다. 전역 변수, 파일, 파이프가 이에 해당한다.

## 통신 구현 방식에 따른 분류

### 대기가 있는 통신

동기화를 지원한다. 요청한 데이터가 도착할 때까지 자동으로 대기 상태에 머무른다. 소켓, 파이프가 이에 해당한다.

### 대기가 없는 통신

동기화를 지원하지 않는다.   바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인한다. 이러한 통신 방식을 가진 예로는 전역 변수, 파일이 있다.

## 프로세스 간 통신의 종류

### 공유 메모리

프로세스들이 **주소 공간의 일부를 공유**하여 공유한 메모리 영역에 읽기/쓰기를 해서 통신을 수행한다. 즉, **프로세스간 메모리 영역을 공유**한다. 프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에게 메모리 공간을 할당해 준다. 공유 메모리 영역이 구축된 이후에는 모든 접근이 일반적인 메모리 접근으로 취급되어 더 이상 **커널의 도움 없이도 각 프로세스들이 공유 메모리 영역에 접근할 수 있다.**

### 특징

- 초기에 공유 메모리 영역을 구축한 이후로는 커널의 관여 없이 데이터 통신이 가능하기 때문에 속도가 빠르다.
- 운영체제가 동기화를 지원하지 않는다.
- 동시에 같은 메모리 위치에 접근할 경우, 일관성 문제가 발생할 가능성이 있다.
-> 이에 대해 커널이 관여하지 않기 때문에 프로세스들끼리 직접 공유 메모리 접근에 대한 동기화 문제를 책임져야 한다.

### 전역 변수 이용

- 공동으로 관리하는 메모리를 사용해 데이터를 주고받는다.
- 데이터를 보내는 쪽에서는 전역 변수나 파일에 값을 쓰고, 받는 쪽에서는 전역 변수의 값을 읽는다.
- 직접적으로 관련이 있는 프로세스간에 사용한다.
- 부모 프로세스가 전역 변수를 선언한 다음 자식 프로세스를 만든다고 가정해 보자. 이렇게 하면 전역 변수를 통해 부모 프로세스와 자식 프로세스가 통신을 할 수 있게 된다. 이 전역 변수는 부모 프로세스와 자식 프로세스가 공유하는 메모리 영역에 위치한다. 두 프로세스는 전역 변수에 읽기 또는 쓰기 연산을 한다.
→ 상대 프로세스가 언제 전역 변수에 데이터를 쓸지 알 수 없기 때문에 계속해서 전역 변수의 값을 확인해야 한다. 즉, 전역 변수의 값이 변할 때까지 바쁜 대기를 한다.

### 파일 이용

- 부모-자식 관계 프로세스 간 통신에 많이 사용된다.
- 주로 부모 프로세스가 wait() 함수를 이용하여 자식 프로세스의 작업이 끝날 때까지 기다렸다가 작업을 시작한다.

### 메시지 전달

통상 시스템 콜을 이용하여 구현된다. 커널을 통해 send(message)와 receive(message) 연산을 제공받는다. 예를 들어 프로세스 A 가 커널에 메시지를 보내면 커널이 프로세스
B 에게 그 메시지를 보내주는 방식이다.

### 특징

- 시스템 콜을 사용하기 때문에 커널의 관여를 받아 속도가 느리다.
- 충돌을 회피할 필요가 없어 적은 양의 데이터를 교환하는 데 유리하다.
- 운영체제가 동기화 방식을 제공하므로 구현하기 쉽다.
- 프로세스 동기화를 지원하므로 바쁜 대기를 하지 않는다.

### 파이프 이용

- 운영체제가 제공하는 동기화 통신 방식
- 단방향 통신. 양쪽 모두 송/수신을 하고 싶으면 2개의 파이프가 필요하다.
- 만약 프로세스 B가 파이프 1에 대해 읽기 연산을 수행했는데 프로세스 A가 아직 파이프 1에 쓰기 연산을 수행하지 않았다면, 프로세스 B는 대기 상태가 된다. 프로세스 A가 파이프 1에 쓰기 연산을 수행하는 순간 자동으로 프로세스 B의 대기 상태가 풀려 동기화가 이루어진다. 즉, 대기 상태 덕분에 프로세스 B는 바쁜 대기를 하지 않는다.
- **이름 없는 파이프**
통신할 프로세스를 명확히 알 수 있는 경우에 사용한다.
부모와 자식 프로세스, 같은 부모를 가진 자식 프로세스와 같이 서로 관련 있는 프로세스 간 통신에 사용된다.
- **이름 있는 파이프**
이름 없는 파이프의 확장 상태이며, 서로 관련 없는 프로세스 간 통신에 사용된다.
****FIFO라 불리는 특수 파일을 이용한다.

### 메시지 큐 이용

- 입출력 방식은 이름 있는 파이프와 동일하다.
- 데이터의 흐름이 아닌 메모리 공간이다.
- 사용할 데이터에 번호를 붙여 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.

### 소켓 이용

- 여러 컴퓨터에 있는 프로세스끼리의 통신 방식으로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다.
- 클라이언트와 서버가 소켓을 통해서 통신하는 구조
- 양방향 통신
- 통신하고자 하는 프로세스는 소켓에 쓰기 연산을 해서 데이터를 전송하거나, 읽기 연산을 해서 데이터를 받는다.

<br>

# 공유 자원과 임계구역

## Race Condition(경쟁 조건)

2개 이상의 스레드가 공유 자원을 병행적으로 읽거나 써서, **공유 자원의 값이 꼬이게 되는** 문제

**예시**

- [입출금 문제](https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EA%B8%88_%EB%AC%B8%EC%A0%9C)
- [생산자-소비자 문제](https://ko.wikipedia.org/wiki/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90_%EB%AC%B8%EC%A0%9C)

예시들과 같은 상황을 방지하기 위해, 스레드 여러 개가 하나의 공유 자원을 변경해야 할 때는, 다른 스레드가 접근중인 자원에는 접근하면 안 된다. 이를 위한 방법이 임계구역이다.

## Critical Section(임계구역)

경쟁 조건의 해결법이다. 공유 자원의 일관성을 유지하기 위해 공유 자원에 접근하는 코드 부분을 임계 구역으로 지정한다. 임계구역은 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역으로, 임계구역에는 한 번에 하나의 스레드만이 들어갈 수 있다.

### 임계구역이 갖춰야 할 3가지 조건

- 상호 배제: 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없다.
- 한정 대기: 어떤 프로세스도 무한히 대기해서는 안된다. 즉, 특정 프로세스가 임계구역에 진입하지 못하면 안된다.
- 진행의 융통성: 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다.

<br>

# 임계구역 해결 방법

참고: [https://hoyeonkim795.github.io/posts/mutex-semaphore/](https://hoyeonkim795.github.io/posts/mutex-semaphore/)

[https://gyoogle.dev/blog/computer-science/operating-system/Semaphore & Mutex.html](https://gyoogle.dev/blog/computer-science/operating-system/Semaphore%20&%20Mutex.html)

[https://steady-coding.tistory.com/517](https://steady-coding.tistory.com/517)

## 하드웨어적인 해결 방법

```c
while (lock == true);
lock = true;

/*
임계 구역
*/

lock = false;
```

잠금이 걸렸는지 검사하는 while문과 검사한 후 잠금 설정을 하는 lock = true문이 분리되어 실행되기 때문에 두 명령어 중간에 타임아웃이 걸리면 상호 배제 문제가 발생한다.

```c
while (testandset(&lock) == true);

/*
임계 구역
*/

lock = false;
```

하드웨어적으로 잠금이 걸렸는지 검사하는 while문과 검사한 후 잠금 설정을 하는 lock = true문을 동시에 실행하면 상호 배제 문제가 생기지 않는다.

- 임계구역을 하드웨어적으로 해결하는 방법은 편리하다.
- 하지만 바쁜 대기가 있다.

## 뮤텍스

제어되는 섹션에 하나의 스레드만 허용한다. 해당 섹션에 접근하려는 다른 스레드를 강제적으로 막는다. 임계구역 해결의 세 가지 조건을 모두 만족한다.

피터슨 알고리즘, 데커 알고리즘을 사용하면 하드웨어의 도움 없이도 임계구역 문제를 해결할 수 있다. 하지만 프로세스가 늘어날수록 변수도 늘어나고 전체적인 알고리즘도 복잡해진다.

### 피터슨 알고리즘

```java
boolean lock1 = false;
boolean lock2 = false;
int turn = 1;
```

```java
lock1 = true;
turn = 2;
while (lock2 == true && turn == 2);

/*
	임계구역
*/

lock1 = false;
```

```java
lock2 = true;
turn = 1;
while (lock1 == true && turn == 1);

/*
	임계구역
*/

lock2 = false;
```

- 두 프로세스가 동시에 lock을 설정하더라도 turn을 사용하여 다른 프로세스에게 양보한다.
    - lock: 프로세스 중 누가 임계구역에 들어갈 것인지 나타내는 변수
    - turn: 누가 임계구역에 들어갈 차례인지 나타내는 변수
- 단 2개의 프로세스만 사용 가능하다.
- 여러 프로세스가 하나의 임계구역을 사용하기 위해서는 공유 변수를 추가하고 코드를 변경해야 한다.
- while을 통한 바쁜 대기를 사용하여 자원을 낭비한다.

### 데커 알고리즘

```java
boolean lock1 = false;
boolean lock2 = false;
int turn = 1;
```

```java
lock1 = true;
while (lock2 == true) {
	if (turn == 2) {
		lock1 = false;
		while (turn == 2);
		lock1 = true;
	}
}

/*
	임계구역
*/

turn = 2;
lock1 = false;
```

```java
lock2 = true;
while (lock1 == true) {
	if (turn == 1) {
		lock2 = false;
		while (turn == 1);
		lock2 = true;
	}
}

/*
	임계구역
*/

turn = 1;
lock2 = false;
```

- 데커와 유사하지만, 상대에게 진입 기회를 양보하는 부분에 차이가 있다.
- 단 2개의 프로세스만 사용 가능하다.
- 여러 프로세스가 하나의 임계구역을 사용하기 위해서는 공유 변수를 추가하고 코드를 변경해야 한다.
- while을 통한 바쁜 대기를 사용하여 자원을 낭비한다.

### 베이커리 알고리즘

참고: [https://en.wikipedia.org/wiki/Lamport's_bakery_algorithm](https://en.wikipedia.org/wiki/Lamport%27s_bakery_algorithm)

```java
AtomicIntegerArray ticket = new AtomicIntegerArray(threads); // ticket for threads in line, n - number of threads
// Java initializes each element of 'ticket' to 0
 
AtomicIntegerArray entering = new AtomicIntegerArray(threads); // 1 when thread entering in line
// Java initializes each element of 'entering' to 0
 
public void lock(int pid) // thread ID
{
    entering.set(pid, 1);
    int max = 0;
    for (int i = 0; i < threads; i++)
    {
        int current = ticket.get(i);
        if (current > max)
        {
            max = current;
        }
    }
    ticket.set(pid, 1 + max); 
    entering.set(pid, 0);
    for (int i = 0; i < ticket.length(); ++i)
    {
        if (i != pid)
        {
            while (entering.get(i) == 1) { Thread.yield(); } // wait while other thread picks a ticket
            while (ticket.get(i) != 0 && ( ticket.get(i) < ticket.get(pid) ||
                    (ticket.get(i) == ticket.get(pid) && i < pid)))
            { Thread.yield(); }
        }
    }
    // The critical section goes here...
}

public void unlock(int pid)
{
  ticket.set(pid, 0);
}
```

- 여러 프로세스/스레드에 대한 처리가 가능하다. 즉, N개의 프로세스가 동시에 작동할 수 있다.
- 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계구역에 진입한다. (번호 우선순위 시스템)
- while을 통한 바쁜 대기를 사용하여 자원을 낭비한다.

## 세마포어

- 데이크스트라가 제안한 알고리즘이다.
- 두 개의 특수한 명령들만 접근할 수 있게 허용되는 보호된 변수이다. 락의 매커니즘을 그대로 활용한다.
- 바쁜 대기를 하지 않는다.
- 임계구역이 잠겼는지 직접 점검하거나, 다른 프로세스에 동기화 메시지를 보내지 않는다.
- 앞의 알고리즘과 비교했을 때 간단하고 사용하기 쉽다.
- 사용 전에 공유 가능한 자원의 수를 N으로 설정한다. 공유 자원은 여러 개 사용할 수 있다.

```java
semaphore(n);
P();
V();

void semaphore(n) {
	RS = n;
}

void P() {
	if (RS > 0)
		RS = RS - 1;
	else
		block(); // 대기
}

void V() {
	RS = RS + 1;
	wakeUp();
}
```

Semaphore(n): 전역 변수 RS를 n으로 초기화한다. RS == 현재 사용 가능한 자원의 개수.

P(): wait 연산. 잠금을 수행하는 코드이다. RS가 0보다 크면 RS를 1 감소시키고 임계구역에 진입하고, RS가 0 이하이면 RS가 1 이상이 될 때까지 기다린다.

V(): 큐에 대기 중인 프로세스를 깨우는 wakeUp 신호로서 signal 연산이다. 잠금 해제와 동기화를 수행한다. RS를 1 증가시키고 세마포어에서 기다리는 프로세스에게 임계구역에 진입해도 좋다는 동기화 신호인 wakeUp 신호를 보낸다.

### 동작 과정

- 프로세스가 임계구역에 진입하기 전에, 세마포어는 스위치를 사용 중으로 놓는다. 프로세스는 임계구역에 진입한다.
- 이후에 도착하는 프로세스는 앞의 프로세스가 작업을 마칠 때까지 세마포어 큐에서 기다린다.
- 프로세스가 작업을 마치면 세마포어가 다음 프로세스에 임계구역을 사용하라는 동기화 신호를 보낸다.

## 모니터

세마포어는 뮤텍스 기법들보다 단순하고 사용하기 편리하지만, 잘못된 사용으로 인해 임계구역이 보호받지 못할 수 있다.

### 세마포어의 잘못된 사용법

- 프로세스가 세마포어를 사용하지 않고 바로 임계구역에 들어간다.
- P()를 2번 사용하면 동기화 신호가 발생하지 않는다.
- P()와 V()의 순서를 반대로 사용하면 상호 배제가 보장되지 않는다.

### 모니터의 특징

- 세마포어의 잘못된 사용을 방지하기 위해 사용한다.
- 공유 자원을 사용할 때 모든 프로세스가 세마포어 알고리즘을 따르게 하여 굳이 P()와 V()를 사용할 필요가 없게 한다.
- 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공하여 자원을 보호하면서 프로세스 간에 동기화를 시킨다. 즉, 임계구역을 보호하기 위해 사용한다. 이는 시스템 호출과 같은 방법이다.
- 사용자 입장에서는 복잡한 코드를 실행하지 않아서 좋고, 시스템 입장에서는 임계구역을 보호할 수 있어서 좋다.

### 모니터의 작동 원리

1. 임계구역으로 지정된 변수나 자원에 접근하고자 하는 프로세스가 모니터에 작업 요청을 한다.
2. 모니터는 요청받은 작업을 모니터 큐에 저장한 후 순서대로 처리하고 그 결과만을 해당 프로세스에게 알려준다.

<aside>
💡 **뮤텍스를 이진 세마포어라고 하기도 한다. 이 때, 이진 세마포어와 뮤텍스의 주요한 차이는?**
뮤텍스는 lock을 건 스레드만이 임계구역을 나갈 때 lock을 해제한다. 세마포어는 lock을 걸지 않은 스레드도 signal을 사용해 락을 해제할 수 있다. 구체적인 예를 들자면, 현재 스레드보다 우선순위가 높은 스레드는 이진 세마포어를 해제하고 잠글 수 있다. 결론적으로 보면, **뮤텍스의 경우 스레드가 뮤텍스의 소유권을 가지지만, 세마포어의 경우 스레드는 세마포어의 소유권을 가질 수 없다.**

</aside>

<br>

# 질문 목록

## 연습문제

### 프로세스 간 통신에서 데이터를 양방향으로 전송 가능하지만 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송할 수 있는 통신 방식은 무엇인가?

### 상태 변화를 살펴보기 위해 반복문을 무한 실행하며 기다리는 것을 무엇이라 하는가?

### 프로세스 간 통신에서 대기가 없는 통신과 대기가 있는 통신의 예를 각각 제시하시오.

### 파이프를 이용하여 통신할 때 파이프를 2개 사용하는 이유는 무엇인가?

### 공유 자원을 병행적으로 읽거나 쓰는 상황을 무엇이라 하는가?

### 공유 자원의 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역은 무엇인가?

### 임계구역 해결 조건 중 한 프로세스가 임계구역에 들어갔을 때 다른 프로세스는 임계구역에 들어갈 수 없는 조건을 무엇이라 하는가?

### 임계구역 해결 조건 중 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다는 조건을 무엇이라 하는가?

### 임계구역 문제를 하드웨어적으로 해결한 방식으로, 하드웨어의 지원을 받아 명령어를 실행하는 도중에 타임아웃이 걸리지 않도록 하는 방식을 무엇이라 하는가?

### 세마포어의 Semaphore(n)에서 n은 무엇을 가리키는가?

### 세마포어에서 내부 변수를 RS라고 할 때 세마포어 P()의 내부 코드를 쓰시오.

### 세마포어에서 내부 변수를 RS라고 할 때 세마포어 V()의 내부 코드를 쓰시오.

### 세마포어가 제대로 작동하지 않는 경우를 설명하시오.

### 세마포어의 내부 코드도 타임아웃이 걸리면 문제가 발생할 수도 있다. 그래서 내부 코드는 무엇으로 보호받는가?

### 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화를 시키는 것으로, 세마포어의 단점을 해결하면서 임계구역 문제를 해결한 방식은 무엇인가?

### 프로세스 간 통신을 통신 방향에 따라 분류하여 설명하시오.

### 대기가 있는 통신과 대기가 없는 통신의 의미를 설명하고 적절한 예를 제시하시오.

### 실생활의 예를 들어 임계구역 문제를 설명하시오.

이하 생략

## 그 외 질문

### 프로세스 간 통신 중 메모리 공유를 하는 방법에는 어떤 것들이 있나요?

### 프로세스 간 통신 중 메시지 전달을 하는 방법에는 어떤 것들이 있나요?

### 피터슨 알고리즘이 무엇인가요?

### 뮤텍스와 세마포어의 차이점은 무엇인가요?

- 그렇다면, 이진 세마포어와 뮤텍스의 차이점은 무엇인가요?