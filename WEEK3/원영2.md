# 프로세스 동기화

## 프로세스 간 통신의 개념

프로세스는 시스탬 내에서 독립적으로 실행되기도 하고 데이터를 주고받으며 협업하기도 한다.

프로세스가 다른 프로세스와 데이터를 주고받는 프로세스 간 통신(IPC)은 같은 컴퓨터내에 있는 프로세스 뿐만 아니라

네트워크로 연결된 다른 컴퓨터에 있는 프로세스와의 통신도 포함된다.

- 프로세스 내부 데이터 통신 : 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신, 프로세스 내부의 스레드는 전역 변수나 파일을 이용하여 데이터를 주고 받는다.

- 프로세스 간 데이터 통신 : 같은 컴퓨터에 있는 여러 프로세스끼리 통신하는 경우로, 공용 파일 또는 운영체제가 제공하는 파이프를 사용하여 통신한다.

- 네트워크를 이용한 데이터 통신 : 여러 컴퓨터가 네트워크로 연결되어 있을 때도 통신이 가능한데, 이 경우 프로세스는 소켓을 이용하여 데이터를 주고 받는다.

<br />

## 프로세스 간 통신의 분류

- 양방향 통신(duplex communication) : 데이터가 동시에 양쪽 방향으로 전송할 수 있는 구조, 소켓 통신이 대표적
- 반양방향 통신(half-duplex communication) : 데이터를 양쪽 방향으로 전송할 수 있지만, 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송할 수 있는 구조이다. 무전기가 대표적
- 단방향 통신(simplex communication) : 모스 신호처럼 한쪽 방향으로만 데이터를 전송할 수 있는 구조, 프로세스 간 통신에서는 전역 변수와 파이프가 단방향 통신에 해당한다.

<br />

## 전역 변수를 활용하는 단방향 통신의 문제점

데이터를 받는 쪽에서는 언제 데이터를 보낼지 모르기 때문에 받는쪽에서 반복적으로 전역 변수의 값을 체크해야 한다.
이렇게 상태 변화를 살펴보기 위해 반복문을 무한 실행하며 기다리는 것을 _바쁜 대기(busy wating)_ 이라 한다.

<br />

## 동기화 통신, 비동기화 통신

바쁜 대기 문제를 해결하기 위해서 데이터가 도착헀음을 알려주는 _동기화(synchronization)_ 를 사용한다.

메신저에서 메시지가 도착했다고 알려주는 알림은 대표적인 동기화 방식, 동기화 방식을 사용하면 바쁜 대기를 하지 않아도 운영체제가 알아서 알려준다.

프로세스 간 통신은 동기화 기능이 있느냐 없느냐에 따라 _대기가 있는 통신(blocking communication)_ 과 _대기가 없는 통신(non-blocking communication_) 으로 나뉜다.

- 대기가 있는 통신(동기화 통신) : 동기화를 지원하는 통신 방식, 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머물러 있다.
- 대기가 없는 통신(비동기화 통신) : 동기화를 지원하지 않는 통신 방식, 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인한다.

<br />

| 분류 방식                  | 종류                            | 예                      |
| -------------------------- | ------------------------------- | ----------------------- |
| 통신 방향에 따른 분류      | 양방향 통신                     | 일반적 통신, 소켓       |
|                            | 반 양방향 통신                  | 무전기                  |
|                            | 단방향 통신                     | 전역 변수, 파일, 파이프 |
| 통신 구현 방식에 따른 분류 | 대기가 있는 통신(동기화 통신)   | 파이프, 소켓            |
|                            | 대기가 없는 통신(비동기화 통신) | 전역 변수, 파일         |

<br />

## 전역 변수를 이용한 통신

전역 변수를 이용한 통신은 공동으로 관리하는 메모리를 사용하여 데이터를 주고받는 것이다.

데이터를 보내는 쪽 -> 전역 변수나 파일에 값을 씀.

데이터를 받는 쪽 -> 전역 변수의 값을 읽음.

전역 변수를 이용한 통신은 주로 직접적인 관계가 있는 프로세스 간에 사용한다. ex) 부모와 자식 프로세스

<br />

## 파일을 이용한 통신

파일을 이용한 통신은 부모-자식 관계 프로세스 통신에 많이 사용되며 운영체제가 프로세스 동기화를 제공하지 않는다.

그래서 프로세스가 알아서 동기화를 해야 하는데 주로 부모 프로세스가 wait() 함수를 이용하여 자식 프로세스의 작업이 끝날 때까지 기다렸다가 작업을 시작한다.

- 파일 열기(open) : 준비 단계, open() 함수를 이용해서 사용하고자 하는 파일이 있는지, 쓰기권한이 있는지 확인, 정상적으로 사용할 수 있다면 open() 함수는 fd를 반환한다. fd는 사용 가능하다는 key이고 fd를 파일 기술자(file descriptor)라고 부른다.

- 읽기 또는 쓰기 연산(read or write) : read() 또는 write() 함수를 써서 권한이 있는 파일에 읽거나 쓴다.

- 파일 닫기(close) : close() 함수를 써서 파일을 닫는다.

<br />

## 파이프를 이용한 통신

프로세스 동기화 문제를 해결하는 방법으로 파이프가 있다.

파이프는 운영체제가 제공하는 동기화 통신 방식으로 파일 입출력과 같이 open() 함수로 기술자를 얻고 close() 함수로 마무리 한다.

파이프를 이용한 통신은 전역 변수를 이용한 통신과 마찬가지로 단방향 통신이다.

파이프로 양방향 통신을 하려면 파이프 2개를 이용해야 한다.

파이프는 _이름 없는 파이프(anonymous pipe)_ 와 _이름 있는 파이프(named pipe)_ 로 나뉜다.

- 이름 없는 파이프 : 일반적으로 파이프라고 하면 이름 없는 파이프를 가리킨다.
  부모-자식 프로세스 같은 서로 관련 있는 프로세스 간 통신에 사용된다.

- 이름 있는 파이프 : FIFO라 불리는 특수 파일을 이용하며 서로 관련 없는 프로세스 간 통신에 사용한다.

<br />

## 소켓을 이용한 통신

여러 컴퓨터에 있는 프로세스간 통신을 네트워킹이라 한다.
소켓은 프로세스 동기화를 지원하므로 데이터를 받는 쪽의 프로세스가 바쁜 대기를 하지 않아도 된다.
소켓은 하나만 사용해도 양방향 통신이 가능하다.

> 네트워크 프로그래밍을 흔히 소켓 프로그래밍이라 한다. 이유는 네트워킹의 기본이 소켓이기 때문이다.

<br />

### 프로세스간 통신 요약

| 종류      | 운영체제 동기화 지원 | open()/close() 사용 |
| --------- | -------------------- | ------------------- |
| 전역 변수 | X(바쁜 대기)         | X                   |
| 파일      | X(wait() 함수 이용   | O                   |
| 파이프    | O                    | O                   |
| 소켓      | O                    | O                   |

<br />

<br />

# 공유 자원과 임계구역

<br />

## 공유 자원의 접근

*공유 자원(shared resource*은 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말한다.

공유 자원은 공동으로 이용되기 때문에 누가 언제 데이터를 읽거나 쓰느냐에 따라서 결과가 달라질 수 있다.

따라서 프로세스들의 공유 자원 접근 순서를 정하여 예상치 못한 문제가 발생하지 않도록 해야 한다.

2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황을 <b>_경쟁 조건(race condition)_</b> 이 발생했다고 한다.

<br />

## 임계구역

공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 <b>_임계구역(critical section)_</b> 이라고 한다.

프로세스 실행 상황에서는 공유할 수 없는 자원이 중요한 자원이다.

<br />

## 임계구역 해결 조건

- 상호 배제(mutual exclusion) : 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없다. 임계 구역 내에는 한 번에 하나의 프로세스만 있어야 한다.
- 한정 대기(bounded wating) : 어떤 프로세스도 무한 대기 하지 않아야 한다. 즉 특정 프로세스가 임계구역에 진입하지 못하면 안 된다.
- 진행의 융통성(progress flexibility) : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다.

<br />

## 임계구역 해결 방법

임계구역 문제를 해결하는 단순한 방법은 _잠금(block)_ 을 이용하는 것이다.

<br />

### 상호 배제 문제

![lock2](https://user-images.githubusercontent.com/103870198/212521608-31c43adf-6af5-44f6-b92a-4e90af71968c.png)

1. 프로세스 P1이 1번 라인을 실행한다. 임계구역에 프로세스가 없으므로 무한 루프를 빠져나온다. 그런데 CPU 타임아웃이 나서 준비 상태로 빠지고 문맥 교환이 발생해서 프로세스 P2가 실행 상태로 바뀐다.
2. 아직 프로세스 P1이 잠금을 걸지 않았기 때문에 lock은 여전히 false이다. 프로세스 P2가 2번 라인을 실행한다. 임계구역에 프로세스가 없기 때문에 무한 루프를 빠져나온다.
3. 프로세스 P1은 lock == true; 실행하고 임계구역에 잠금을 걸고 진입한다.
4. 프로세스 P2도 lock == true; 실행하고 임계구역 잠금을 걸고 진입한다. 결국 둘 다 임계구역에 진입한다.

<br />

<br />

### 한계 문제

아래 상황 처럼 두 프로세스가 무한 루프를 빠져 나오지 못하고 임계구역에 진입하지 못하는 상황을 <b>_교착 상태(deadlock)_</b> 라고 한다.

교착 상태는 프로세스가 살아 있으나 작업이 진행되지 못하는 상태를 말한다.

![lock3](https://user-images.githubusercontent.com/103870198/212521725-77114fda-5a5b-488f-b203-a42ff75a4931.png)

1. 프로세스 P1이 lock1 == true; 실행한 후 타임아웃
2. 프로세스 P2도 lock2 == true; 실행 하고 타임아웃
3. 프로세스 P2가 lock2 == true; 했기 때문에 프로세스 P1은 무한 루프에 빠진다
4. 마찬가지로 프로세스 P1이 lock1 == true; 했기 때문에 프로세스 P2도 무한 루프에 빠진다.

<br />

<br />

### 진행의 융통성 문제

아래 그림은 공유 변수 lock 의 값이 1이면 프로세스P1이 임계구역을 사용한다는 것이고, lock의 값이 2이면

프로세스 P2가 임계구역을 사용한다는 뜻이다.

![Untitled 6](https://user-images.githubusercontent.com/103870198/212521885-9fe7a078-95ee-4462-87ac-0a555d05803c.png)

위 방식은 상호 배제와 한정 대기를 보장하지만, 서로 번갈아가면서 실행 된다는 것이 문제이다.

한 프로세스가 두 번 연달아 임계구역에 진입하고 싶어도 못하는 구조이다.

이렇게 프로세스의 진행이 다른 프로세스로 인해 방해받는 현상을 _경직된 동기화(lockstep synchronization)_ 이라 한다.

<br />

## 세마포어(semaphore)

세마포어는 임계구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계구역으로 들어간다.

이후에 도착하는 프로세스는 앞의 프로세스가 작업을 마칠 떄가지 기다린다.

프로세스가 작업을 마치면 세마포어는 다음 프로세스에 임계구역을 사용하라는 동기화 신호를 보낸다.

![semaphore](https://user-images.githubusercontent.com/103870198/212522615-7585b7c4-3fd0-48ad-b155-4aab45528113.png)

- Semaphore(n) : 전엿 변수 RS를 n으로 초기화한다. RS 에는 현재 사용 가능한 자원의 수가 저장된다.
- P() : 잠금을 수행하는 코드로, RS가 0보다 크면(사용 가능하면) 1만큼 감소시키고 임계구역에 진입한다, 만약 RS가 0보다 작으면(사용 불가능) 0보다 커질때가지 기다린다.
- V() : 잠금 해제와 동기화를 같이 수행하는 코드로, RS 값을 1 증가시키고 세마포어에서 기다리는 프로세스에게 임계구역에 진입해도 좋다는 wake_up() 신호를 보낸다.

<br />

## 모니터(monitor)

세마포어는 단순하고 사용하기 편리하지만 잘못된 사용으로 인해 임계구역을 보호받지 못할 수도 있다.

공유 자원을 사용할 때 모든 프로세스가 세마포어 알고리즘을 따른다면 굳이 P() 와 V() 를 사용할 필요 없이 자동으로 처리하면 된다.

모니터는 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화를 시킨다.

모니터는 임계구역 보호와 동기화를 위해 내부적으로 상태 변수(condition variable) 을 사용한다.

- wait() : 모니터 큐에서 자신의 차례가 올 때까지 기다린다. 세마포어의 P() 에 해당한다.
- signal() : 모니터 큐에서 기다리는 다음 프로세스에 순서를 넘겨준다. 세마포어에 V()에 해당한다.

<br />

<br />

<hr />

- 교착상태의 발생 조건 4가지를 설명해주세요.
- 뮤텍스가 뭘까요?
- 이진 세마포어는 왜 이진 세마포어 인가요?

교착 상태?

![robot](https://user-images.githubusercontent.com/103870198/212526331-ee3e0f56-e8fb-4920-8b59-9a1e1a119384.jpg)
