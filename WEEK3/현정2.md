# 프로세스 동기화

## 1. 프로세스 간 통신
<br/>

### [프로세스 간 통신의 개념]
<br/>
  프로세스는 시스템 내에서 독립적으로 실행되기도 하지만 데이터를 주고 받으며 협업하기도 한다. 프로세스가 다른 프로세스와 데이터를 주고 받는 프로세스 간 통신(IPC)에는 같은 컴퓨터 내에 있는 프로세스뿐만 아니라 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와의 통신도 포함된다. 

  - 프로세스 내부 데이터 통신 : 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신. 전역 변수나 파일을 이용하여 데이터를 주고 받는다.
  - 프로세스 간 데이터 통신 : 같은 컴퓨터에 있는 여러 프로세스끼리의 통신. 공용 파일, 운영체제가 제공하는 파이프를 이용하여 통신한다.
  - 네트워크를 이용한 데이터 통신 : 여러 컴퓨터가 네트워크로 연결되어 있을 때도 통신이 가능한데, 이 경우 소켓을 이용하여 데이터를 주고 받는다. 이를 네워킹이라고 부른다. 
<br/>

### [프로세스 간 통신의 분류]
<br/>

  - 통신 방향에 따른 분류  
   - 양방향 통신 : 데이터를 양쪽 방향으로 전송할 수 있는 구조로 일반적인 통신은 모두 양방향 통신이다.
   - 반양방향 통신 : 데이터를 양쪽 방향으로 전송할 수 있지만 동시 전송은 불가능하고 한 번에 한 쪽 방향으로만 전송할 수 있는 구조로 대표적인 예는 무전기가 있다.
   - 단방향 통신 : 한쪽 방향으로만 데이터를 전송할 수 있는 구조로 전역 변수나 파이프가 이에 해당한다.

<br/>

  - 통신 구현 방식에 따른 분류
    - 대기가 있는 통신(동기화 통신) : 동기화를 지원하는 통신 방식이다. 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머물러 있다.
    - 대기가 없는 통신(비동기화 통신) : 동기화를 지원하지 않는 통신 방식이다. 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인한다. 

<br/>

### [프로세스간 통신의 종류]
<br/>

  - 전역 변수를 이용한 통신
    - 공동으로 관리하는 메모리를 사용하여 데이터를 주고 받는다. 주로 직접적으로 관련이 있는 프로세스 간에 사용하는데 예를 들어 부모 프로세스가 전역 변수를 선언한 수 자식 프로세스를 만들면 부모 프로세스와 자식 프로세스가 통신을 할 수 있다. 
    - 바쁜 대기(busy waiting)을 해야하는 문제가 있다.
  - 파일을 이용한 통신
    - 파일 열기, 쓰기/읽기, 닫기로 구성
    - 부모-자식 관계 프로세스 간의 통신에 많이 사용되며 운영체제가 프로세스 동기화를 제공하지 않는다. 
  - 파이프를 이용한 통신
    - 파일 입출력과 같이 open() 함수로 기술자 얻고 작업 한 후 close() 함수로 마무리하며 운영체제가 제공하는 동기화 통신 방법이다.
    - 단방향 통신이므로 양방향 통신을 하려면 파이프를 2개 사용해야 한다.
  - 소켓을 이용한 통신     
    - 여러 컴퓨터에 있는 프로세스 간 통신을 위해 사용하는 방법
    - 소켓은 프로세스 동기화를 지원하므로 바쁜 대기를 하지 않아도 되고, 소켓 하나만으로도 양방향 통신이 가능하다. 
<br/>

## 2. 공유자원과 임계구역
<br/>

### [공유 자원의 접근]
<br/>

* 공유 자원 : 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말한다. 

  공유 자원은 공동으로 이용되기 때문에 누가 언제 데이터를 읽거나 쓰느냐에 따라 그 결과가 달라질 수 있다. 따라서 데이터의 일관성을 유지하려면 프로세스들을 올바른 순서대로 수행하는 매커니즘이 필요하다. 

* 임계 구역 : 공유 자원에 접근하는 순서에 따라 실행 결과가 달라지는 프로그램의 영역으로 프로세스들이 동시에 작업하지 못하도록 보장해주어야 한다.

<br/>

### [임계구역 해결 조건]
<br/>
 
 - 상호 배제 (mutual exclusion) : 한 프로세스가 임계 구역에 들어가면 다른 프로세스는 임계 구역에 들어갈 수 없다. 
 - 한정 대기 (bounded waiting) : 어떤 프로세스도 무한 대기하지 않아야 한다.
 - 진행의 융통성(progress flexibility) : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다. 

<br/>

## 3. 임계구역 해결 방법
<br/>

 임계구역 문제를 해결하는 단순한 방법은 lock을 이용하는 것이다.  

 ### [상호 배제 문제]
<br/>

```
//p1
while(lock==true);
lock = true;
//임계구역
lock = false;


//p2
while(lock==true);
lock = true;
//임계구역
lock = false;

```

- lock이 true일 때에는 무한 루프를 돌면서 대기하고 lock이 false일 때에는 무한 루프를 빠져나와 작업을 한다. 
- 문제점 
  - lock = false 일 때, lock = true로 바꾸기 직전에 타임아웃되는 경우, 동시에 임계구역에 진입하게 될 수 있다.

### [한정 대기 문제]
<br/>

```
//p1
lock1= true;
while(lock2==true);
//임계구역
lock1 = false;

//p2
lock2= true;
while(lock1==true);
//임계구역
lock2 = false;
```
- p1은 임계구역에 진입하기 전에 먼저 잠금을 설정하고 p2가 잠금을 설정했는지 확인한 후 임계구역에 진입한다. p2도 같은 방식으로 임계구역에 진입한다.
- 잠금을 먼저 걸고 다른 프로세스가 잠겼는지 확인하므로 상호 배제는 보장이 된다. 
- 문제점 
  - p1과 p2가 모두 lock을 건 직후에 타임아웃이 오면 두 프로세스 모두 무한 루프에 빠질 수 있다. 이를 교착 상태(deadlock)이라 한다.
  - 프로세스가 늘어나는 만큼 검사해야하는 lock 수도 늘어나 비효율적이기 때문에 확장성에 문제도 있다.

### [진행의 융통성 문제]
<br/>

```
//p1
while(lock==2);
//임계구역
lock=2;

//p2
while(lock==1);
//임계구역
lock=1;

```

 - 공유 변수 lock의 값을 통해 다른 프로세스가 임계구역에 있는지 확인하고, 없으면 진입한다. 그리고 임계구역을 빠져나올 때 lock 값을 바꾼다.
 - 상호배제와 한정대기를 보장하는 코드
 - 문제점
   - 각각의 프로세스는 다른 프로세스가 나온 다음에야 진입할 수 있기 때문에 서로 진행을 방해하는 구조가 된다. (경직된 동기화)


### [하드웨어적인 해결방법]
<br/>

```
while(testandset(&lock) == true);
//임계구역
lock ==false;

```


- 잠금이 걸렸는지 검사하는 구문과 검사한 후 잠금을 설정하는 구문을 동시에 실행하여 임계구역 문제를 해결할 수 있다.(검사와 지정)
- 문제점
  - 바쁜 대기를 사용하여 검사하기 때문에 자원 낭비가 있다.  

### [세마포어]
<br/>

 임계구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계 구역에 들어간다. 그 이후 프로세스는 작업을 기다리며, 프로세스가 작업을 마치면 동기화 신호를 보낸다. 다른 알고리즘과는 달리 임계구역이 잠겼는지 직접 점검하거나 바쁜 대기를 하거나, 메시지를 보낼 필요가 없다. 
 
```
Semaphore(n);  // 혆재 사용 가능한 자원의 수가 저장됨
P();  // 잠금을 수행하는 코드로, 사용 가능한 자원이 있으면 1만큼 감소시키고 임계구역에 진입한다. 
// 임계구역
V(); // 잠금해제와 동기화를 같이 수행하는 코드. 세마포어에서 기다리는 프로세스에게 wake_up 신호를 보낸다. 

```

### [모니터]
<br/>

 모든 프로세스가 세마포어 알고리즘을 따른다면 잠금/ 잠금 해제, 동기화를 자동으로 처리하면 되는데 이것을 구현한 것이 모니터이다.
 모니터는 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스간 동기화를 시킨다.
 
