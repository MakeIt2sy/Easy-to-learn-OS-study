# CHAPTER 04 CPU 스케줄링

# 스케줄링의 개요

## 스케줄링

여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일

## CPU 스케줄러

프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정하는 일을 한다. CPU 스케줄러가 하는 일이 스케줄링이다.

## 스케줄링의 목적

- 공평성: 모든 프로세스가 자원을 공평하게 배정받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안된다.
- 효율성: 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 준다.
- 안정성: 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써, 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호한다.
- 확장성: 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치해야 한다. 시스템 자원이 증가하는 경우 그 자원이 시스템에 반영되게 해야 한다.
- 반응 시간 보장: 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
- 무한 연기 방지: 특정 프로세스의 작업이 무한히 연기되어서는 안된다.

## 스케줄링의 단계

규모에 따라 고수준 스케줄링, 중간 수준 스케줄링, 저수준 스케줄링으로 구분된다.

![https://blog.kakaocdn.net/dn/LWsTP/btqADYNqTLF/cG56Qkczo8H6kDezOQsWiK/img.png](https://blog.kakaocdn.net/dn/LWsTP/btqADYNqTLF/cG56Qkczo8H6kDezOQsWiK/img.png)

### 고수준 스케줄링

- 시스템 내의 전체 작업 수(동시에 실행 가능한 프로세스의 총 개수, 멀티프로그래밍 정도)를 조절하는 것이다.
- 가장 큰 틀에서 이루어지는 스케줄링이다.
- 전체 시스템의 부하를 고려하여 어떤 작업 요청이 들어왔을 때 그 작업 요청을 시스템이 받아들일지 또는 거부할지를 결정한다.
- 승인 스케줄링, 장기 스케줄링, 작업 스케줄링으로도 불린다.
- 메인프레임과 같은 큰 시스템에서 규모가 큰 일괄 작업을 처리할 때 사용된다.

### 중간 수준 스케줄링

- 고수준 스케줄링을 통해 활성화된 프로세스가 시스템에 과부하를 일으킬 경우, 중지와 활성화를 통해 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다. 즉, 일부 프로세스를 보류 상태로 보내고, 처리 능력에 여유가 생기면 보류된 프로세스를 다시 활성화한다.
- 저수준 스케줄링이 원만하게 이뤄지도록 완충하는 역할을 한다. (buffer)

### 저수준 스케줄링

- 가장 작은 단위의 스케줄링이며, 실제 작업이 이루어진다.
- 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정한다.
- 프로세스 상태와 관련이 깊다. 예를 들어, 준비 상태에 있는 프로세스 중 하나를 골라 실행 상태로 보내고, 실행 상태에 있는 프로세스를 대기 상태로 보내며, 대기 상태의 프로세스를 준비 상태로 보낸다.
- 아주 짧은 시간 안에 일어나기 때문에, 단기 스케줄링이라고 부른다.

<br>

# 스케줄링 시 고려 사항

## 선점 VS 비선점

### preemptive(선점)

- 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 **CPU를 강제로 빼앗을 수 있는** 스케줄링 방식
- 컨텍스트 스위칭 등의 부가적인 작업으로 인해 낭비가 생긴다.
- 하나의 프로세스가 CPU를 독점할 수 없기 때문에, 빠른 응답 시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합하다.
- 대부분의 저수준 스케줄러가 사용한다.
- 예: CPU가 인터럽트를 받으면 현재 실행 중인 작업을 중단하고 커널을 깨워서 인터럽트를 처리시키며, 인터럽트 처리가 완료되면 원래 작업으로 돌아간다.

### non-preemptive(비선점)

- 어떤 프로세스가 CPU를 할당받아 실행 중이면 다른 프로세스가 **CPU를 강제로 빼앗을 수 없는** 스케줄링 방식
- 스케줄러의 작업량이 적다.
- 컨텍스트 스위칭에 의한 낭비가 적다.
- CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 프로세스 여러 개가 오랫동안 기다리게 되어 전체 시스템의 처리율이 떨어진다.
- 일괄 작업 시스템에서 사용하는 방식이다.
- 선점형과 비선점형 프로세스가 혼재하는 경우 비선점형 프로세스의 우선순위를 매우 낮게 설정한다.
- 예: 시스템을 백업하는 프로세스의 경우 비선점으로 작동한다.

## 프로세스 우선순위

- 커널 프로세스의 우선순위 > 일반 프로세스의 우선순위
- 전면 프로세스 > 후면 프로세스
- 대화형 프로세스 > 일괄 처리 프로세스
- 입출력 집중 프로세스 > CPU 집중 프로세스
- 우선순위가 높다 == 더 빨리 자주 실행된다.
- 일반 프로세스의 우선순위는 사용자가 프로세스의 우선순위를 조절할 수 있다.

## CPU 집중 프로세스 VS 입출력 집중 프로세스

- CPU 버스트: CPU를 할당받아 실행하는 작업
- 입출력 버스트: 입출력 작업

### CPU 집중 프로세스

수학 연산과 같이 CPU를 많이 사용하는 프로세스를 말한다. CPU 버스트가 많은 프로세스이다.

### 입출력 집중 프로세스

저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스를 말한다. 입출력 버스트가 많은 프로세스이다.

<aside>
💡 **CPU 집중 프로세스와 입출력 집중 프로세스가 같이 있을 때**
입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적이다. 입출력 집중 프로세스가 실행 상태로 가면 입출력 요구에 의해 대기 상태로 옮겨지기 때문에 다른 프로세스가 CPU를 사용할 수 있다. 만약 CPU 집중 프로세스가 먼저 실행 상태로 들어간다면 자신의 타임 슬라이스를 다 쓸 때까지 다른 프로세스가 실행되지 못할 것이다.
스케줄링 시 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스의 우선순위보다 높이면 시스템의 효율이 향상된다. 이 경우에, 입출력 프로세스가 CPU 집중 프로세스보다 실행 상태에 먼저 들어가는 것을 사이클 훔치기라고 한다.

</aside>

<br>

## 전면 프로세스 VS 후면 프로세스

### 전면 프로세스

- GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스
- 후면 프로세스보다 우선순위가 높다.
- 현재 입출력을 사용하는 프로세스 → 사용자와 상호작용 가능
- 사용자의 요구에 즉각 반영해야 한다.
- 상호작용 프로세스라고도 한다.

### 후면 프로세스

- 사용자의 입력이 없다. → 사용자와 상호작용이 없다.
- 일괄 작업 프로세스라고도 한다.

<br>

# 다중 큐

## 준비 상태의 다중 큐

프로세스 우선순위는 PCB에 표시된다. CPU 스케줄러는 매번 준비 큐에 있는 모든 PCB를 뒤져서 우선순위가 가장 높은 프로세스를 찾아 CPU를 할당한다. 이런 경우 CPU를 할당할 프로세스를 찾는 데 많은 시간이 걸린다.

→ 이를 보완하기 위해 같은 우선순위별로 분류하여 큐를 만든다. 이렇게 하면 우선순위에 따라 여러 개의 큐가 생긴다.

→ 우선순위가 가장 높은 큐에 있는 프로세스 중 하나에 CPU를 할당하면 되므로, CPU를 할당할 프로세스를 찾는 데 적은 시간이 걸린다.

### 프로세스의 우선순위 배정 방식

- 고정 우선순위 방식: 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식이다. 구현하기 쉽지만, 시시각각 변하는 시스템의 변화에 대응하기 어려워 작업 효율이 떨어진다.
- 변동 우선순위 방식: 프로세스 생성 시 부여받은 우선순위가 작업 중간에 변하는 방식이다. 구현하기 어렵지만 시스템의 효율을 높일 수 있다.
    - A 프로세스가 어떤 자원을 독점하고 있다고 가정하고, B 프로세스가 그 자원을 필요로 한다고 가정한다. A 프로세스의 우선순위를 높여 CPU를 자주 할당받게 만들어 빨리 작업을 끝내야 B 프로세스가 해당 자원을 사용할 수 있게 된다. 이렇게 프로세스의 낮은 우선순위를 높은 우선순위로 바꾸는 것을 반전 우선순위라고 한다.

## 대기 상태의 다중 큐

시스템 내에는 다양한 종류의 입출력장치가 존재하기 때문에 대기 상태의 프로세스를 한곳에 모아놓으면 관리하기 불편하다. 예를 들어, HDD에서 작업이 끝났다는 완료 인터럽트가 발생한 경우, 해당 프로세스를 찾기 위해 대기 상태의 모든 프로세스를 탐색해야 한다면 번거롭다. 

→ 같은 장치의 입출력을 기다리는 프로세스의 PCB는 동일한 입출력 큐에 모아 놓는다.

입출력장치는 CPU나 메모리보다 느리기 때문에 작업 순서를 뒤바꾸는 경우가 있다.

→ 큐에 나중에 들어온 PCB가 먼저 준비 상태로 옮겨 가기도 한다.

### 인터럽트 벡터

![인터럽트_벡터.png](https://yansigit.github.io/posts/%ec%9d%b8%ed%84%b0%eb%9f%bd%ed%8a%b8%ec%99%80-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%ed%86%b5%ec%8b%a0/Untitled.png)

시스템에는 많은 입출력장치가 있기 때문에 입출력이 동시에 끝날 경우 여러 개의 인터럽트(완료 인터럽트)가 한 번에 처리된다. 인터럽트 벡터는 이렇게 동시에 끝나는 인터럽트를 처리하기 위해 사용하는 자료구조이다. 인터럽트 벡터에는 동시에 완료된 입출력 정보와 처리 방법이 담겨 있다.

인터럽트가 발생하면 인터럽트 벡터의 번호가 0에서 1로 바뀐다. 인터럽트 벡터는 인터럽트와 인터럽트 핸들러를 1대 1로 연결해준다.

### 준비 상태의 다중 큐와의 차이

준비 큐는 한 번에 하나의 프로세스를 꺼내어 CPU를 할당한다.

대기 큐는 동시에 여러 개의 PCB를 꺼내어 준비 상태로 옮긴다.

<br>

# 스케줄링 알고리즘

### 스케줄링 알고리즘 선택 기준

- CPU 사용률: 전체 시스템의 동작 시간 중 CPU가 사용된 시간
- 처리량: 단위 시간당 작업을 마친 프로세스의 개수
- 대기 시간: 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간
- 응답 시간: 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간
- 실행 시간: 프로세스 작업이 시작된 후 종료되기까지의 시간
- 반환 시간: 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간. 반환 시간 = 대기 시간 + 실행 시간

스케줄링 알고리즘의 성능을 비교할 때는 주로 평균 대기 시간을 본다.

## Preemptive Algorithm

### 라운드 로빈

순환 순서 방식이다. 한 프로세스가 할당받은 시간동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다린다. 선점형 알고리즘 중 가장 단순하고 대표적인 방식이다. 프로세스들이 작업을 완료할 때까지 계속 순환하면서 실행한다.

장점: 프로세스가 CPU를 일정 시간 동안 사용한 후 다른 프로세스에 주어야 하기 때문에 콘보이 효과가 줄어든다.

단점: 비선점형 알고리즘과 비교했을 때, 평균 대기시간이 같다면 비효율적일 수 있는 방식이다. 컨텍스트 스위칭이 자주 일어나기 때문이다.

### SRT

Shortest Remaining Time. SJF 스케줄링과 라운드 로빈 스케줄링을 혼합한 방식이다. SJF 스케줄링의 선점형 버전이라 할 수 있다. 기본적으로 라운드 로빈 스케줄링을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업 시간이 가장 적은 프로세스를 선택한다. 단점 때문에 잘 사용되지는 않는다.

단점: 현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 컨텍스트 스위칭을 해야 하므로 SJF 스케줄링에는 없는 작업이 추가된다. SJF 스케줄링과 마찬가지로 운영체제가 프로세스의 실행 시간을 정확하게 예측하기 어렵고 아사 현상이 일어날 수 있다.

### 다단계 큐 스케줄링

Multilevel Queue. 우선순위에 따라 준비 큐를 여러 개 사용하는 방식이다. 우선순위에 따른 각 큐마다 각각의 타임 슬라이스를 조절하여 작업 효율을 높일 수 있다. 우선순위는 고정형 우선순위를 사용하며, 우선순위가 높은 큐에 있는 모든 작업이 끝나야 다음 우선순위 큐의 작업이 시작된다. 즉, 우선순위가 높은 프로세스 때문에 우선순위가 낮은 프로세스의 작업이 연기된다.

### 다단계 피드백 큐 스케줄링

Multilevel Feedback Queue. 스케줄링 우선순위가 낮은 프로세스에 매우 불리한 다단계 큐 스케줄링의 문제점을 보완한 방식이다. 다단계 큐 스케줄링의 경우 각 단계의 큐에 라운드 로빈 방식을 사용하며, 프로세스가 실행된 후에는 큐의 뒤쪽에 들어갈 뿐, 우선순위에는 변화가 없다. 다단계 피드백 큐 스케줄링의 경우, CPU를 사용한 프로세스의 우선순위가 낮아진다. 즉, 원래의 큐로 되돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어간다.

프로세스가 실행될 때마다 프로세스의 우선순위를 낮춘다. → 다단계 큐에서 우선순위가 낮은 프로세스의 실행이 계속 연기되는 문제를 완화한다.

우선순위가 낮은 프로세스의 타임 슬라이스를 크게 설정한다. → CPU를 얻기 힘든 우선순위가 낮은 프로세스가 어렵게 얻은 CPU를 좀 더 오랫동안 사용할 수 있도록 한다.

오늘날의 운영체제가 CPU 스케줄링을 위해 일반적으로 사용하는 방식이며, 변동 우선순위 알고리즘이다.

## Non-Preemptive Algorithm

### FCFS 스케줄링

First Come First Served. 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식이다.

장점: 단순하고 공평하다.

단점: 콘보이 효과가 있으며, 현재 작업 중인 프로세스가 입출력 작업을 요청할 경우 CPU가 작업하지 않고 쉬는 시간이 많아진다.

콘보이 효과: 실행 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 하염없이 기다려 시스템의 효율성이 떨어지는 문제

### SJF 스케줄링

Shortest Job First. 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업에 먼저 CPU를 할당하는 비선점형 방식이다. 실행 시간이 짧은 프로세스에 먼저 CPU를 할당하기 때문에 콘보이 효과를 완화할 수 있다.

장점: 실행 시간이 짧은 작업을 먼저 실행하기 때문에 평균 대기 시간이 줄어들어 시스템의 효율성이 좋아진다.

단점: 운영체제가 프로세스의 실행 시간을 정확하게 예측하기 어렵다. 실행 시간이 긴 작업은 계속 뒤로 밀려 아사 현상(무한 봉쇄)이 발생할 수 있다. 이는 프로세스의 공평성을 떨어뜨리는 일이다.

### HRN 스케줄링

Highest Response Ratio Next. SJF 스케줄링에서 발생할 수 있는 아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘이다. SJF 스케줄링은 프로세스의 실행 시간이 판단 기준이기 때문에 항상 적은 시간을 사용하는 프로세스에 우선권이 주어지지만, HRN 스케줄링은 서비스를 받기 위해 기다린 시간과 CPU 사용 시간을 고려하여 스케줄링을 하는 방식이다.

HRN 스케줄링에서 프로세스의 우선순위는 다음 식에 따라 결정된다.

우선순위 = (대기 시간 + CPU 사용 시간) / CPU 사용 시간

장점: 아사 현상을 완화한다. SJF 스케줄링과 비교했을 때 대기 시간이 긴 프로세스가 CPU를 할당받을 확률이 높다.

단점: 여전히 공평성이 위배된다.

## 둘 다 가능한 방식

### 우선순위 스케줄링

- 프로세스의 우선순위를 반영한 스케줄링 알고리즘이다.
- 만약 커널 프로세스가 일반 프로세스와 같은 우선순위를 가지고 있다면, 일반 프로세스가 실행된 다음 커널 프로세스가 실행될 경우 커널 프로세스가 제 역할을 못할 수도 있다. 이때문에 프로세스의 우선순위는 시스템의 효율성이 아닌 프로세스의 중요도를 기준으로 결정된다.
- 준비 큐에 있는 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU를 할당하므로 공평성을 위배하고 아사 현상을 일으킨다.
- 우선순위를 매번 바꿔야 하기 때문에 오버헤드가 발생하여 시스템의 효율성이 떨어진다.

### Starvation과 Aging

우선순위가 높은 프로세스에 먼저 CPU를 할당하므로, 우선순위가 낮은 프로세스는 계속 CPU를 할당받지 못해 Starvation(아사 현상)이 일어날 수 있다.

이는 Aging(나이 들어감)으로 해결할 수 있다. 이는 사람이 나이를 먹듯이 프로세스가 자신의 순서를 양보할 때마다 우선순위가 높아지는 것이다.

<br>

# 인터럽트 처리

## 인터럽트의 개념

CPU가 프로그램을 실행하는 도중, **주변장치들이 CPU의 서비스를 필요로 하게 될 때** 그 **서비스를 요청하기 위해** 발생시키는 신호이다.

예를 들어, 어떤 프로세스가 실행 도중 다른 프로세스가 사용 중인 메모리 영역을 침범하면 CPU에 있는 메모리 관련 레지스터가 인터럽트를 발생시켜 해당 프로세스를 강제 종료한다.

추가: [인터럽트](https://www.notion.so/CHAPTER-02-da9ffdad94cb44c2b8a1c4df5eafb498)

## 동기적 인터럽트

프로세스가 실행 중인 명령어로 인해 발생한다.

- 프로그램상의 문제(다른 사용자의 메모리 영역에 접근, 오버플로, 언더플로 등)
- 사용자가 프로세스를 중단하기 위해 의도적으로 발생시키는 경우(Ctrl + C 등)
- 주변장치의 조작(입출력장치 등)
- 산술 연산 중 발생하는 경우(Division by zero 등)

## 비동기적 인터럽트

프로세스가 실행 중인 명령어와 무관하게 발생한다. 하드웨어적 오류로 인해 발생한다.

- 하드디스크 읽기 오류
- 메모리 불량
- 키보드 인터럽트
- 마우스 인터럽트

## 인터럽트 처리 과정

1. 인터럽트가 발생한다. 현재 실행 중인 프로세스는 일시 정지 상태가 되며, 현재 실행 중인 프로세스와 관련된 정보를 임시로 저장한다.
2. 인터럽트 컨트롤러가 실행되어 인터럽트의 처리 순서를 결정한다. 만약 여러 개의 인터럽트가 동시에 발생했다면 인터럽트 우선순위를 고려하여 중요한 인터럽트부터 처리하도록 순서를 결정한다.
3. 처리할 인터럽트가 결정되면 인터럽트 벡터에 등록된 인터럽트 핸들러가 실행된다.
4. 인터럽트 핸들러가 인터럽트 처리를 마치면, 일시 정지된 프로세스가 다시 실행되거나 종료된다. 입출력 완료 같은 인터럽트라면 다시 실행되는 것이고, 다른 프로세스의 메모리 영역 침범이나 오류 같은 경우이면 종료되는 것이다.

## 듀얼 모드

- 커널 모드: 운영체제와 관련된 커널 프로세스가 실행되는 상태
- 사용자 모드: 사용자 프로세스가 실행되는 상태

운영체제가 두 모드를 전환하며 일 처리를 하는 것을 듀얼 모드라고 한다.

### 모드 비트

커널 모드와 사용자 모드를 구분짓기 위해 사용한다. 0은 커널 모드이고, 1은 유저 모드이다. 모드비트의 사용을 통해 운영체제를 위해 실행되는 작업과 사용자를 위해 실행되는 작업을 구분할 수 있다.

### 듀얼 모드의 목적

운영체제가 자원을 보호하기 위해 사용한다. 사용자 프로세스가 시스템 자원에 직접 접근하면 문제가 발생할 수 있기 때문에 커널은 시스템 콜을 통해서만 자원에 접근하도록 제한한다. 즉, 사용자 프로세스가 커널 모드에서 실행되지 못하게 한다.

### 사용자가 커널 모드로 진입하는 경우

- 시스템 콜: 사용자가 자발적으로 진입한다.
    
    사용자 프로세스가 시스템 콜을 통해 커널의 기능을 사용하려 한다.
    
    → 사용자 프로세스는 시스템 콜을 한 후 대기 상태로 전환된다.
    
    → 커널 프로세스는 요청받은 작업을 처리한다.
    
- 인터럽트: 사용자가 비자발적으로 진입한다.
    
    어떤 프로세스에서 잘못된 명령을 수행한다.
    
    → 어떤 프로세스가 동기적 인터럽트를 발생시킨다. 프로세스는 강제 종료된다.
    
<br>

# 질문 목록

## 연습문제

### 시스템 내 전체 프로세스의 수를 조절하는 것으로, 장기 스케줄링 또는 작업 스케줄링이라 불리는 스케줄링 수준은 무엇인가?

### 어떤 프로세스에 CPU를 할당하고 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 스케줄링 수준은 무엇인가?

### 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링은 무엇인가?

### 현재 입출력을 진행하는 프로세스로, 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 불리는 것은 무엇인가?

### 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 스케줄링 알고리즘은 무엇인가?

### 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 스케줄링 알고리즘은 무엇인가?

### SJF 스케줄링 알고리즘의 단점으로 크기가 큰 작업이 계속 뒤로 밀리는 현상을 무엇이라고 하는가?

### 아사 현상을 해결하는 방법을 설명하시오.

### 프로세스가 할당받은 시간(타임 슬라이스) 동안 작업하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 다음 자기 차례가 올 때까지 기다리는 선점형 스케줄링 알고리즘 중 가장 단순한 것은 무엇인가?

### 타임 슬라이스의 크기와 문맥 교환의 관계를 설명하시오.

### 시스템 내 전체 프로세스의 수를 조절하는 것으로, 장기 스케줄링 또는 작업 스케줄링이라 불리는 스케줄링 수준은 무엇인가?

### 기본적으로 라운드 로빈 방식을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업 시간이 가장 적은 것을 선택하는 스케줄링 알고리즘은 무엇인가?

### 우선순위에 따라 준비 큐를 여러 개 사용하며 고정형 우선순위를 적용하는 스케줄링 알고리즘은 무엇인가?

### 우선순위에 따라 준비 큐를 여러개 사용하며, 프로세스가 CPU를 사용한 후 우선순위가 낮아지는 특징을 가진 스케줄링 알고리즘은 무엇인가?

### 다단계 피드백 큐 스케줄링에서 마지막 큐에 있는 프로세스(우선순위가 가장 낮은 프로세스)의 타임 슬라이스 크기는 얼마인가?

### 다단계 피드백 큐 스케줄링에서 우선순위가 낮아질수록 타임 슬라이스의 크기는 어떻게 변하는가?

### 다단계 피드백 큐 스케줄링에서 마지막 큐(우선순위가 가장 낮은 큐)는 어떤 스케줄링 알고리즘처럼 동작하는가?

### 스케줄링의 단계와 그 특징을 설명하시오.

### 스케줄링의 목적을 설명하시오.

### 선점형 스케줄링과 비선점형 스케줄링을 비교하여 설명하시오.

### 스케줄링 알고리즘의 선택 기준에 대해 설명하시오.

### FCFS, SJF, HRN 스케줄링의 특징을 설명하시오.

### 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐 스케줄링의 특징을 설명하시오.

### 아사 현상과 에이징에 대해 설명하시오.

### 타임 슬라이스의 크기를 정하는 것과 시스템 효율성에 대해 설명하시오.

<br>

## 그 외 질문

### 듀얼 모드가 무엇이고, 왜 사용하나요?

### CPU 작업을 주로 하는 프로세스와 입출력 작업을 주로 하는 프로세스가 있다면, 어떤 프로세스를 먼저 실행하는 게 효율적일까요?