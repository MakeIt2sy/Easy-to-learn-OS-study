# CHAPTER 04 CPU 스케줄링

# 스케줄링의 개요

## 스케줄링

여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일

## CPU 스케줄러

프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정하는 일을 한다. CPU 스케줄러가 하는 일이 스케줄링이다.

## 스케줄링의 목적

- 공평성: 모든 프로세스가 자원을 공평하게 배정받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안된다.
- 효율성: 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 준다.
- 안정성: 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써, 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호한다.
- 확장성: 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치해야 한다. 시스템 자원이 증가하는 경우 그 자원이 시스템에 반영되게 해야 한다.
- 반응 시간 보장: 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
- 무한 연기 방지: 특정 프로세스의 작업이 무한히 연기되어서는 안된다.

## 스케줄링의 단계

규모에 따라 고수준 스케줄링, 중간 수준 스케줄링, 저수준 스케줄링으로 구분된다.

![https://blog.kakaocdn.net/dn/LWsTP/btqADYNqTLF/cG56Qkczo8H6kDezOQsWiK/img.png](https://blog.kakaocdn.net/dn/LWsTP/btqADYNqTLF/cG56Qkczo8H6kDezOQsWiK/img.png)

### 고수준 스케줄링

- 시스템 내의 전체 작업 수(동시에 실행 가능한 프로세스의 총 개수, 멀티프로그래밍 정도)를 조절하는 것이다.
- 가장 큰 틀에서 이루어지는 스케줄링이다.
- 전체 시스템의 부하를 고려하여 어떤 작업 요청이 들어왔을 때 그 작업 요청을 시스템이 받아들일지 또는 거부할지를 결정한다.
- 승인 스케줄링, 장기 스케줄링, 작업 스케줄링으로도 불린다.
- 메인프레임과 같은 큰 시스템에서 규모가 큰 일괄 작업을 처리할 때 사용된다.

### 중간 수준 스케줄링

- 고수준 스케줄링을 통해 활성화된 프로세스가 시스템에 과부하를 일으킬 경우, 중지와 활성화를 통해 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다. 즉, 일부 프로세스를 보류 상태로 보내고, 처리 능력에 여유가 생기면 보류된 프로세스를 다시 활성화한다.
- 저수준 스케줄링이 원만하게 이뤄지도록 완충하는 역할을 한다. (buffer)

### 저수준 스케줄링

- 가장 작은 단위의 스케줄링이며, 실제 작업이 이루어진다.
- 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정한다.
- 프로세스 상태와 관련이 깊다. 예를 들어, 준비 상태에 있는 프로세스 중 하나를 골라 실행 상태로 보내고, 실행 상태에 있는 프로세스를 대기 상태로 보내며, 대기 상태의 프로세스를 준비 상태로 보낸다.
- 아주 짧은 시간 안에 일어나기 때문에, 단기 스케줄링이라고 부른다.

<br>

# 스케줄링 시 고려 사항

## 선점 VS 비선점

### preemptive(선점)

- 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 **CPU를 강제로 빼앗을 수 있는** 스케줄링 방식
- 컨텍스트 스위칭 등의 부가적인 작업으로 인해 낭비가 생긴다.
- 하나의 프로세스가 CPU를 독점할 수 없기 때문에, 빠른 응답 시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합하다.
- 대부분의 저수준 스케줄러가 사용한다.
- 예: CPU가 인터럽트를 받으면 현재 실행 중인 작업을 중단하고 커널을 깨워서 인터럽트를 처리시키며, 인터럽트 처리가 완료되면 원래 작업으로 돌아간다.

### non-preemptive(비선점)

- 어떤 프로세스가 CPU를 할당받아 실행 중이면 다른 프로세스가 **CPU를 강제로 빼앗을 수 없는** 스케줄링 방식
- 스케줄러의 작업량이 적다.
- 컨텍스트 스위칭에 의한 낭비가 적다.
- CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 프로세스 여러 개가 오랫동안 기다리게 되어 전체 시스템의 처리율이 떨어진다.
- 일괄 작업 시스템에서 사용하는 방식이다.
- 선점형과 비선점형 프로세스가 혼재하는 경우 비선점형 프로세스의 우선순위를 매우 낮게 설정한다.
- 예: 시스템을 백업하는 프로세스의 경우 비선점으로 작동한다.

## 프로세스 우선순위

- 커널 프로세스의 우선순위 > 일반 프로세스의 우선순위
- 전면 프로세스 > 후면 프로세스
- 대화형 프로세스 > 일괄 처리 프로세스
- 입출력 집중 프로세스 > CPU 집중 프로세스
- 우선순위가 높다 == 더 빨리 자주 실행된다.
- 일반 프로세스의 우선순위는 사용자가 프로세스의 우선순위를 조절할 수 있다.

## CPU 집중 프로세스 VS 입출력 집중 프로세스

- CPU 버스트: CPU를 할당받아 실행하는 작업
- 입출력 버스트: 입출력 작업

### CPU 집중 프로세스

수학 연산과 같이 CPU를 많이 사용하는 프로세스를 말한다. CPU 버스트가 많은 프로세스이다.

### 입출력 집중 프로세스

저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스를 말한다. 입출력 버스트가 많은 프로세스이다.

<aside>
💡 **CPU 집중 프로세스와 입출력 집중 프로세스가 같이 있을 때**
입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적이다. 입출력 집중 프로세스가 실행 상태로 가면 입출력 요구에 의해 대기 상태로 옮겨지기 때문에 다른 프로세스가 CPU를 사용할 수 있다. 만약 CPU 집중 프로세스가 먼저 실행 상태로 들어간다면 자신의 타임 슬라이스를 다 쓸 때까지 다른 프로세스가 실행되지 못할 것이다.
스케줄링 시 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스의 우선순위보다 높이면 시스템의 효율이 향상된다. 이 경우에, 입출력 프로세스가 CPU 집중 프로세스보다 실행 상태에 먼저 들어가는 것을 사이클 훔치기라고 한다.

</aside>

<br>

## 전면 프로세스 VS 후면 프로세스

### 전면 프로세스

- GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스
- 후면 프로세스보다 우선순위가 높다.
- 현재 입출력을 사용하는 프로세스 → 사용자와 상호작용 가능
- 사용자의 요구에 즉각 반영해야 한다.
- 상호작용 프로세스라고도 한다.

### 후면 프로세스

- 사용자의 입력이 없다. → 사용자와 상호작용이 없다.
- 일괄 작업 프로세스라고도 한다.

<br>

# 다중 큐

## 준비 상태의 다중 큐

프로세스 우선순위는 PCB에 표시된다. CPU 스케줄러는 매번 준비 큐에 있는 모든 PCB를 뒤져서 우선순위가 가장 높은 프로세스를 찾아 CPU를 할당한다. 이런 경우 CPU를 할당할 프로세스를 찾는 데 많은 시간이 걸린다.

→ 이를 보완하기 위해 같은 우선순위별로 분류하여 큐를 만든다. 이렇게 하면 우선순위에 따라 여러 개의 큐가 생긴다.

→ 우선순위가 가장 높은 큐에 있는 프로세스 중 하나에 CPU를 할당하면 되므로, CPU를 할당할 프로세스를 찾는 데 적은 시간이 걸린다.

### 프로세스의 우선순위 배정 방식

- 고정 우선순위 방식: 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식이다. 구현하기 쉽지만, 시시각각 변하는 시스템의 변화에 대응하기 어려워 작업 효율이 떨어진다.
- 변동 우선순위 방식: 프로세스 생성 시 부여받은 우선순위가 작업 중간에 변하는 방식이다. 구현하기 어렵지만 시스템의 효율을 높일 수 있다.
    - A 프로세스가 어떤 자원을 독점하고 있다고 가정하고, B 프로세스가 그 자원을 필요로 한다고 가정한다. A 프로세스의 우선순위를 높여 CPU를 자주 할당받게 만들어 빨리 작업을 끝내야 B 프로세스가 해당 자원을 사용할 수 있게 된다. 이렇게 프로세스의 낮은 우선순위를 높은 우선순위로 바꾸는 것을 반전 우선순위라고 한다.

## 대기 상태의 다중 큐

시스템 내에는 다양한 종류의 입출력장치가 존재하기 때문에 대기 상태의 프로세스를 한곳에 모아놓으면 관리하기 불편하다. 예를 들어, HDD에서 작업이 끝났다는 완료 인터럽트가 발생한 경우, 해당 프로세스를 찾기 위해 대기 상태의 모든 프로세스를 탐색해야 한다면 번거롭다. 

→ 같은 장치의 입출력을 기다리는 프로세스의 PCB는 동일한 입출력 큐에 모아 놓는다.

입출력장치는 CPU나 메모리보다 느리기 때문에 작업 순서를 뒤바꾸는 경우가 있다.

→ 큐에 나중에 들어온 PCB가 먼저 준비 상태로 옮겨 가기도 한다.

### 인터럽트 벡터

시스템에는 많은 입출력장치가 있기 때문에 입출력이 동시에 끝날 경우 여러 개의 인터럽트(완료 인터럽트)가 한 번에 처리된다. 인터럽트 벡터는 이렇게 동시에 끝나는 인터럽트를 처리하기 위해 사용하는 자료구조이다. 인터럽트 벡터에는 동시에 완료된 입출력 정보와 처리 방법이 담겨 있다.

### 준비 상태의 다중 큐와의 차이

준비 큐는 한 번에 하나의 프로세스를 꺼내어 CPU를 할당한다.

대기 큐는 동시에 여러 개의 PCB를 꺼내어 준비 상태로 옮긴다.

<br>

# 스케줄링 알고리즘

# 인터럽트 처리

# 질문 목록

## 연습문제

### 

## 그 외 질문

###