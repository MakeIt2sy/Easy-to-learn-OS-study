# 프로세스 동기화

### 프로세스 간 통신의 종류

- 프로세스 내부 데이터 통신 : 한 프로세스 내에서 스레드 간의 통신을 뜻한다. 프로세스 내부의 스레드는 전역변수나 파일을 이용하여 데이터를 주고 받는다.
- 프로세스 간 데이터 통신 : 같은 컴퓨터에 있는 여러 프로세스끼리 통신하는 경우로, 공용 파일 또는 운영체제가 제공하는 파이프를 사용하여 통신한다.
- 네트워크를 이용한 데이터 통신 : 여러 컴퓨터가 네트워크로 연결되어 있을 때도 통신이 가능한데, 이 경우 프로세스는 소켓을 이용하여 데이터를 주고 받는다. 이처럼 소켓을 이용하는 프로세스 간 통신을 네트워킹이라고 한다.

### 프로세스 간 통신의 분류

<table>
  <tr>
    <th>분류 방식</th>
    <th>종류</th>
    <th>예</th>
  </tr>
  <tr>
    <td rowspan="3">통신 방향에 따른 분류</td>
    <td>양방향 통신</td>
    <td>일반적 통신, 소켓</td>
  </tr>
  <tr>
    <td>반양방향 통신</td>
    <td>무전기</td>
  </tr>
  <tr>
    <td>단방향 통신</td>
    <td>전역 변수, 파일, 파이프</td>
  </tr>
  <tr>
    <td rowspan="2">통신 구현 방식에 따른 분류</td>
    <td>대기가 있는 통신(동기화 통신)</td>
    <td>파이프, 소켓</td>
  </tr>
  <tr>
    <td>대기가 없는 통신(비동기 통신)</td>
    <td>전역 변수, 파일</td>
  </tr>
</table>

### 전역 변수를 이용한 통신

![](https://shacoding.com/wp-content/uploads/2022/04/image-86.png)

공동으로 관리하는 메모리에 있는 전역변수를 통하여 통신하는 방식이다. 한 프로세스가 전역변수에 쓰기 연산을 하면 다른 프로세스가 **폴링**방식으로 그 전역변수에 읽기 연산을 하는 방식이다.

### 파일을 이용한 통신

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRPTojEjsRLB3eECoAbOItLdpJ0Vo_CyOImhw&usqp=CAU)

한 프로세스가 open()과 함수가 반환한 file descriptor를 이용해 하드디스크에 저장된 파일에 쓰기 연산을 하고 close()로 닫으면 다른 프로세스가 다시 open()과 반환된 file discriptor를 이용해 해당 파일에 읽기 연산을 하고 close()로 닫는 방식이다. 주로 부모-자식 프로세스간에 자주 사용되며 운영체제가 동기화를 제공하지 않으므로 부모 프로세스가 wait() 함수를이용하여 자식 프로세스의 작업이 끝날때까지 대기했다가 작업을 시작한다.

### 파이프를 이용한 통신

![](https://yansigit.github.io/posts/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%ED%86%B5%EC%8B%A0/Untitled%206.png)

파일 입출력처럼 open()으로 file descriptor를 얻고 작업을 하고 close()로 닫는다. 파이프를 이용한 통신은 전역 변수와 마찬가지로 단방향 통신이며 양방향 통신을 하려면 파이프 2개를 이용하면 된다. 한 프로세스가 파이프에 쓰기 연산을 하면 다른 프로세스가 해당 파이프에 읽기 연산을 하는데 해당 파이프에 쓰기 연산이 완료되지 않았다면 완료될 때 까지 대기하는 방식을 취한다.

파이프는 익명 파이프와 네임드 파이프로 나뉜다.

- 익명 파이프(anonymous pipe) : 일반적인 파이프로, 부모와 자식 프로세스 혹은 같은 부모를 가진 자식 프로세스처럼 관련 있는 프로세스 간 통신에 사용된다.
- 네임드 파이프(named pipe) : FIFO라는 특수 파일을이용하며 서로 관련 없는 프로세스 간 통신에 사용된다.

### 소켓을 이용한 통신

![](https://velog.velcdn.com/images%2Fchappi%2Fpost%2Ff6d8042a-1393-469e-b0f4-afc4ca908cd9%2F6.png)

서로 다른 컴퓨터(host)간에 이루어지는 통신을 네트워킹이라고 하는데 이는 소켓을 통해 이루어진다. 양방향 통신이며, 소켓에 쓰기 연산을 하면 데이터가 전송되고 읽기 연산을 하면 데이터를 받을 수 있다. polling 방식이 아닌 입출력 대기 방식을 사용한다.

### 임계구역

![](https://yansigit.github.io/posts/%EA%B3%B5%EC%9C%A0%EC%9E%90%EC%9B%90%EA%B3%BC-%EC%9E%84%EA%B3%84%EA%B5%AC%EC%97%AD/Untitled.png)

위 그림처럼 2개 이상의 프로세스가 공유하는 자원에 대해 한 프로세스가 쓰기 작업을 마치기 전에 다른 프로세스가 작업을 하게 되면 문제가 발생할 수 있다. 이런 문제가 발생할 수 있는 프로그램의 영역을 임계구역(critical section)이라고 하며 임계구역에서는 2개 이상의 프로세스가 동시에 작업하면 안된다.

### 임계구역 해결 조건

- mutual exclusion(상호배제) : 한 프로세스가 임계구역에서 작업중이면 다른 프로세스는 접근할 수 없다.
- bounded waiting(한정대기) : 임계구역에서 대기중인 프로세스가 starvation에 빠지면 안된다.
- progress flexibility(진행 융통성) : 임계 구역에 들어간 프로세스가 없다면 다음에 어떤 프로세스가 들어갈 지 유연하게 결정해야 한다.

### 임계구역 해결 조건을 방해하는 상황

- 동시 진입
- 교착 상태(dead lock)
- 경직된 동기화(lockstep synchronization)
- busy waiting(polling)

### 피터슨 알고리즘

![](https://mblogthumb-phinf.pstatic.net/MjAyMDA3MTdfNDcg/MDAxNTk0OTY3NDc0MDcz.ZEA-TIjhzGOlyqB_YRF1G0K_YRTi3aB7KjALBcnPbZAg.1P2gQzA7gfgmCW2M5QZhkK6pBAJmOMg6hWdolNGVyUMg.PNG.yjuj0117/image.png?type=w800)

변수 turn은 교착 상태를 방지하기 위한 변수인데, 두 프로세스가 동시에 lock을 설정하더라도 turn을 사용해 다른 프로세스에게 양보할 수 있다. 피터슨 알고리즘은 임계구역 해결 조건 3가지를 다 충족하지만 임계구역을 사용하는 프로세스의 수에 따라 코드가 복잡해진다는 단점이 있다.

### 데커 알고리즘

![](https://yansigit.github.io/posts/%EA%B3%B5%EC%9C%A0%EC%9E%90%EC%9B%90%EA%B3%BC-%EC%9E%84%EA%B3%84%EA%B5%AC%EC%97%AD/Untitled%209.png)

1. P1이 잠금을 건다.
2. 프로세스 P2의 잠금이 걸렸는지 확인한다.
3. P2도 잠금을 걸었다면 turn을 확인한다. P1의 차례라면 임계구역으로 진입한다. P2의 차례라면 P1은 잠금을 풀고 P2가 작업을 마칠 때까지 기다렸다가 마치면 잠금을 걸고 임계구역으로 이동한다.

데커알고리즘의 경우에도 프로세스 수에 따라 코드가 복잡해진다는 단점이 있다.

### 세마포어

![](https://velog.velcdn.com/images/lil_young/post/bbb5b749-af2a-45cc-b8de-d14a8f609523/image.png)

- Semaphore(n) : 전역 변수 RS를 n으로 초기화 한다. RS에는 현재 사용 가능한 자원의 수가 저장된다.
- P() : 잠금을 수행하는 코드로, RS가 0보다 크면 1만큼 감소시키고 임계구역에 진입한다. 만약 RS가 0보다 작으면 0보다 커질 때까지 기다린다.
- V() : 잠금 해제와 동기화를 같이 수행하는 코드로, RS 값을 1 증가시키고 세마포어에서 기다리는 프로세스에게 임계구역에 진입해도 좋다는 wake_up 신호를 보낸다.

#### 작동 과정

- 공유자원이 1개 일 때

1. 먼저 도착한 P1이 1인 RS를 1 감소시키고 임계구역에 진입한다.
2. 나중에 도착한 P2는 현재 RS값이 0이므로 P1이 임계구역을 빠져나올 때까지 세마포어 큐에서 기다린다.
3. 작업을 마친 P1은 V()를 실행하여 RS값을 1 증가시키고 wake_up 신호를 P2에 보낸다.
4. P2가 임계구역에 진입해 작업한다.

- 공유자원이 여러 개 일때(Semaphore(n)의 초기값이 2)

1. P1이 RS값을 1 감소시키고 임계구역에 진입한다.
2. P2도 RS값을 1 감소시키고 임계구역에 진입한다.
3. P3은 RS값이 0이므로 세마포어 큐에서 기다린다.
4. P1이 작업을 마치고 V()를 실행하면 RS값은 1이 되고 wake_up 신호가 프로세스 P3에 저장된다.
5. P3가 임계구역에 진입한다.

### 모니터

세마포어를 사용자가 직접 구현하려다 보면 잘못 사용하는 경우가 종종 생긴다. 이를 방지하기 위해 사용자 프로세스가 system call로 커널 프로세스를 호출하는 방식의 인터페이스를 제공하는게 모니터 방식이다.

### 파일 통신 진행과정

파일과의 통신은 open() 함수로 시작하는데 파일을 여는 방식은 readonly, read/write, writeonly, create 등이 있고, 이 조건들을 만족하면 file descriptor를 리턴한다. 부모 프로세스가 파일의 open()을 실행하고 fork()로 자식 프로세스를 만들면 fd관련정보는 모두 복사되며 자식 프로세스는 따로 open()을 할 필요가 없고 fd는 공유해서 사용한다. fd는 현재 파일을 읽고있는 위치나 권한등을 저장하는데, 관련함수를 이용해 위치를 변경하거나 읽기, 쓰기가 가능하다. 파일을 이용한 입출력은 운영체제에서 동기화를 지원하기 않기 때문에 프로세스가 wait()을 사용하여 동기화를 직접 해주어야 한다.

### 파이프 통신 진행과정

파이프는 익명파이프와 네임드파이프로 나뉘는데 일반적으로 파이프는 서로 관련있는 부모-자식간 통신을 할 때 사용하는 익명파이프를 얘기하며, 익명파이프에 대해 다룰것이다. 파이프도 파일과 마찬가지로 fd를 이용하는데, 차이점은 파일의 경우에는 read()와 write()가 fd를 공유하지만 파이프의 경우에는 따로 존재한다. 그리고 파이프 통신에는 락이 존재하기 때문에 wait() 함수를 이용하지 않아도 된다.

### 네트워킹

소켓을 이용한 통신도 open(), read()/write(), close() 구조를 사용한다. 기본적으로 호스트간의 통신이므로 클라이언트와 서버로 구조가 나뉘는데, 먼저 클라이언트에서 소켓을 생성한 후 connect()를 사용해 서버와 접속을 시도한다. 서버와 접속되면 read() 혹은 write() 작업을 하고 작업이 끝나면 socket descriptor를 닫고 종료한다. 서버측에서는 먼저 소켓을 생성한 후 bind()를 사용하여 생성한 소켓을 특정 포트에 등록한다. 소켓이 정상적으로 등록되면 listen()을 실행하여 클라이언트에서 오는 데이터를 받을 준비를하고 accept()를 통해 들어오는 1개이상의 요청에 대해 하나를 골라 작업을 시작한다. 서버도 마찬가지로 read()나 write() 작업을 하고 작업이 끝나면 생성된 socket descriptor를 닫고 다음 클라이언트를 기다린다.

---

질문거리

- 파이프를 이용한 통신방식에 대해서 설명해주세요
- 익명 파이프와 네임드 파이프는 어떻게 다른가요?
- 소켓을 이용한 통신방식에 대해서 설명해주세요
- 임계구역이 뭔가요?
- 임계구역 해결 조건에는 어떤게 있을까요?
- 교착 상태(dead lock)가 뭔가요?
- 교착 상태, 경쟁 상태, 기아상태는 서로 어떤점에서 다른가요?
- 피터슨 알고리즘 & 데커 알고리즘과 세마포어의 차이점이 뭔가요?
- 세마포어의 진행과정을 설명해주세요
- 소켓이 뭔가요?
- 소켓 통신이 진행되는 과정을 설명해주세요
