# Chapter 5 프로세스 동기화

---

# Q&A:
- 바쁜 대기란?
- 임계구역이란?
- 경쟁 조건이란?
- 임계구역문제 해결방법
  
---

# 프로세스 간 통신
- 프로세스는 시스템 내에서 독립적으로 실행되기도 하고, 프로세스 간에 데이터를 주고 받기도 한다
- 프로세스가 다른 프로세스와 데이터를 주고받은 프로세스 간 통신 IPC는 크게 프로세스 내부 통신, 프로세스 간 데이터 통신, 네트워크를 이용한 통신이 있다.

### 프로세스 내부 데이터 통신
- 하나의 프로세스에 2개 이상의 스레드가 존재하는 경우의 통신으로, 프로세스의 전역 변수나 파일등을 이용하여 데이터를 주고 받는다.

### 프로세스 간 데이터 통신
- 같은 컴퓨터에 있는 여러 프로세스끼리 통신하는 경우로, 공용 파일 또는 운영체제가 제공하는 파이프를 사용하여 통신한다.

### 네트워크를 이용한 통신
- 여러 컴퓨터가 네트워크로 연결되어 있을 때 소켓을 이용하여 데이터를 주고 받으며 통신한다.


## Busy Waiting(바쁜 대기)
> 전역 변수를 사용하는 통신 방식인 경우, 데이터 수신자는 데이터를 언제 받아야 할지 모르기 때문에, 반복문을 무한 실행하며 대기하는 것을 바쁜 대기라고 한다
시스템 차원에서 큰 자원 낭비이다.

##  전역 변수를 이용한 통신
- 공동으로 관리하는 메모리를 사용하여 데이터를 주고받는다.
- 직접적으로 관련이 있는 프로세스 간에 사용한다 ex) 부모 프로세스와 자식 프로세스, 프로세스의 쓰레드간
- 데이터를 보내는쪽에서는 전역 변수나 파일에 값을 쓰고, 데이터를 받는쪽에서는 전역 변수의 값을 읽는다
- **운영체제가 프로세스의 동기화를 제공하지 않고, 데이터를 받는 프로세스는 전역 변수의 값이 변할때까지 바쁜 대기를 해야 한다.**

##  파일을 이용한 통신
> 파일 입출력은 크게 파일 열기, 파일 쓰기, 파일 읽기, 파일 닫기 연산으로 이루어진다.
- 파일을 이용한 통신은 부모-자식 프로세스 간 통신에 많이 사용되며, 운영체제가 프로세스 동기화를 제공해주지 않는다
- **프로세스가 알아서 동기화를 해야하므로 주로 부모 프로세스는 자식 프로세스의 작업이 종료될 때까지 기다리고, 작업이 끝나면 작업을 시작한다**

## 파이프를 이용한 통신
- **운영체제가 제공하는 동기화 통신 방식이며, 바쁜 대기를 하지 않는다.**
- 전역 변수를 이용한 통신과 마찬가지로 단방향 통신이고, 파이프로 양방햔 통신을 하려면 파이프를 2개 사용해야한다
- 데이터를 보내는 프로세스가 파이프에 쓰기 연산을 하면, 데이터가 파이프를 통해 전송된다
- 데이터를 받는 프로세스는 파이프에 읽기 연산을 수행하는데, 파이프에 받을 데이터가 없다면 파이프에 데이터가 올때까지 대기를 하고, 파이프에 받을 데이터가 있다면 데이터를 읽어 대기 상태가 풀린다
  
## 소켓을 이용한 통신
- 네트워크로 연결된 다른 컴퓨터에 있는 프로세스 간 통신 방법이다.
- **소켓은 프로세스 동기화를 지원하므로, 데이터를 받는 쪽의 프로세스가 바쁜 대기를 하지 않아도 된다.**

---
# 공유자원과 임계구역

## 공유 자원의 접근
> 공유 자원은 여러 프로세스가 공동으로 사용하는 변수,메모리,파일등을 말한다
- 공유 자원은 공동으로 이용되기 때문에 누가 언제 데이터를 읽거나 쓰느냐에 따라 상태값이 달라진다
- **따라서 프로세스들의 공유 자원 접근을 제어하여야 한다.**


## Race Condition(경쟁 조건)
> 2개 이상의 프로세스가 동일한 공유 자원에 접근하여 조작할때, 실행 결과가 접근이 발생한 순서에 의존하는 상태를 말한다.

## 임계구역 문제

> **임계구역이란**
> 
> **공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 말한다.**
> 각 프로세스는 임계구역이라고 부르는 코드 부분을 포함하고 있고, 그 안에서 공유 자원에 접근하거나, 조작하는 작업을 수행한다.

- **임계 구역에 대한 실행을 제어하지 않는다면 공유 자원의 상태가 원하는 결과로 변경되지 않는 동기화 문제가 발생한다.**

### 임계구역 문제 해결 조건
1. 상호 배제(mutual exclusion)
   - 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없어야 한다.
2. 한정 대기(bounded wating)
   - 어떤 프로세스도 임계구역에 진입하기 위해 무한 대기하지 않아야 된다.
   - 즉, 특정 프로세스가 임계구역에 진입하지 못하면 안된다.
3. 진행(progress)
   - 임계 구역에 들어간 프로세스가 없다면, 임계 구역에 들어가려는 프로세스는 임계 구역에 들어갈 수 있어야 한다.
   - 프로세스는 다른 프로세스의 진행을 방해해서는 안된다.

- 프로세스의 임계구역에서 발생하는 동기화 문제를 해결하기 위해서는 위 세가지 조건을 만족해야 한다.

---

# 임계구역 해결 방법

## 피터슨 알고리즘
> 바쁜 대기 사용

*공유변수*
- `flag[i] = flag[j] = false;`
- `turn= i;`


*코드*

``process i``
```c++
flag[i] = true; // 락 설정
turn = j; 
while(flag[j] && turn==j); // 대기

Critical Section;

flag[i] = false; // 락 해제
```

`process j`
```c++
flag[j] = true; // 락 설정
turn = i; 
while(flag[i] && turn==i); // 대기

Critical Section;

flag[j] = false; // 락 해제
```

- 상호배제,한정대기,진행 모두 만족한다
- 여러 프로세스가 하나의 임계구역을 사용하려면 공유 변수를 추가하고 코드를 변경해야 하는 단점이 있다.

## 데커 알고리즘
> 바쁜 대기 사용

*공유변수*
- `flag[i] = flag[j] = false;`
- `turn= i;`

*코드*

``process i``
```c++
flag[i] = true; // 락 설정
while (flag[j]==true){
    if (turn==j) {
        flag[i]=false;
        while(turn==j); // 대기
        flag[i]=true;
    }
}

Critical Section;

turn=j;
flag[i]=true;
```

`process j`
```c++
flag[j] = true; // 락 설정
while (flag[i]==true){
    if (turn==i) {
        flag[j]=false;
        while(turn==i); // 대기
        flag[j]=true;
    }
}

Critical Section;

turn=i;
flag[j]=true;
```

- 피터슨 알고리즘이나 데커 알고리즘은 임계구역 문제 해결의 세가지 조건을 모두 만족하지만
- 프로세스가 늘어나면 변수도 늘어나고 전체 알고리즘도 복잡해진다.

## 세마포어
- 앞선 피터슨,데커 알고리즘은 바쁜 대기를 사용하여 자원을 낭비하고 알고리즘도 복잡하다.

- 세마포어는 다른 알고리즘과 달리 임계구역이 잠겼는지 직접 점검하거나, 바쁜대기를 하거나, 다른 프로세스에 동기화 메시지를 보낼 필요가 없다.

```c++

Semaphore(n); // 전역변수 RS 설정 (RS에 현재 사용가능한 자원의 수를 저장)

P(); // if RS>0 then RS--; else block(); until RS>0

Critical Section;

V(); // RS++; wake_up();

```

- 세마 포어에서 잠금이 해제되기를 기다리는 프로세스는 세마포어 큐에 저장되어 있다가 `wake_up` 신호를 받으면 큐에서 나와 임계 구역에 진입한다.
    - 바쁜 대기를 하는 프로세스가 없다.
- **하지만, 세마포어의 `P()` 혹은 `V()` 내부코드가 실행되는 도중에 다른 코드가 실행되면 상호배제나 한정 대기 조건을 보장하지 못한다.**
  - **그러므로, `P()` 혹은 `V()` 내부코드는 atomic 하게 실행되게 해야 한다.**
- 세마포어를 제대로 작성하지 못하면 임계구역 문제가 발생하는 것이 가장 큰 문제다.

## 모니터
> **공유 자원을 모니터 안으로 내부적으로 숨기고, 공유 자원에 대한 접근 인터페이스만 제공하므로써 공유 자원을 보호하고 프로세스 간 동기화를 시킨다.**


`예제 자바 코드`
```java
class monitor{
    
    private int balnce = 10; // shared data
    private boolean busy = false;
    private condition mon; // condition variable

    public increase(int amount){
        if (busy==true) { // 임계구역 사용중인 프로세스가 있다면 wating in queue
            mon.wait();
        } else{ 
            busy = true; // Lock 설정
            balance += amount; // Critical Section
            mon.signal(); // wake up next wating process
        }
    }

}
```

- 임계구역의 보호나 프로세스의 동기화가 모니터 내부에서 처리되므로 사용자는 `increse()`만 호출하면 된다.
- 모니터는 임계구혁 보호나 동기화를 위해 내부적으로 상태 변수를 사용한다.
  - `wait()` : 모니터 큐에서 자신의 차례가 올때까지 기다린다.
  - `signal()` : 모니터 큐에서 기다리는 다음 프로세스에 순서를 넘겨준다.
- 객체지향의 캡슐화는 이와 유사한 동작을 한다.

  

---

# 파일,파이프,소켓 통신

## 파일

-   파일 열기: `open(filename,mode)-> return fd`  (mode = 읽기 전용, 읽기/쓰기, 쓰기 전용, 생성 등이 있음)
-   파일 쓰기: `write()`  
-   파일 읽기: `read()`  
-   파일 닫기: `close()`

- `fork` 이전에 파일을 open 하면 생성된 파일 기술자가 자식 프로세스에도 상속된다.
- 파일 기술자의 위치 정보는 부모 프로세스와 자식 프로세스가 공유하므로, 자식 프로세스가 파일 기술자의 위치를 옮기면 부모 프로세스 또한 같은 위치를 바라본다.
- **파일을 이용한 통신도 전역 변수를 이용한 통신과 마찬가지로 운영체제가 두 프로세스 간 동기화를 지원해주지 않으므로, 프로세스가 알아서 동기화를 해야한다.**
  
> **파일 디스크립터(File Descriptor)**란 리눅스 혹은 유닉스 계열의 시스템에서 프로세스(process)가 파일(file)을 다룰 때 사용하는 개념으로, 프로세스에서 특정 파일에 접근할 때 사용하는 추상적인 값이다. 파일 디스크럽터는 일반적으로 0이 아닌 정수값을 갖는다. 
>
> 흔히 **유닉스 시스템에서 모든 것을 파일이라고 한다.** 일반적인 정규파일부터 디렉토리, 소켓, 파이프, 블록 디바이스, 케릭터 디바이스 등 모든 객체들을 파일로 관리한다. 유닉스 시스템에서 프로세스가 이 파일들을 접근할 때 파일 디스크립터라는 개념을 이용한다. 프로세스가 실행 중에 파일을 Open하면 커널은 해당 프로세스의 파일 디스크립터 숫자 중 사용하지 않는 가장 작은 값을 할당해준다. **그 다음 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근할 때, 파일 디스크립터(FD)값을 이용해서 파일을 지칭할 수 있다.**
>
> 프로그램이 프로세스로 메모리에서 실행될 때, 기본적으로 할당되는 파일디스크립터는 표준입력(Standard Input), 표준 출력(Standard Output), 표준에러(Standard Error)이며 이들에게 각각 0, 1, 2라는 정수가 할당된다.
>
> 참고: https://dev-ahn.tistory.com/96,https://twofootdog.tistory.com/51


## 파이프
- **파이프는 OS 에서 지원해주는 동기화 통신이며, 주로 부모와 자식 프로세스 혹은 같은 부모의 자식 프로세스처럼 서로 관련 있는 프로세스 간 통신에 사용된다.**
- 파이프에서는 read(),write() 기술자가 따로 존재한다.
- 파이프는 단방향 통신이므로 프로세스 당 하나의 파일 기술자만 사용한다.

## 네트워킹
- 소켓 통신을 한다
- 소켓 통신은 동기화 통신이다.
- 파이프와 달리 양방향 통신을 지원한다



 
