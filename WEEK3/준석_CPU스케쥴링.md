# CPU 스케쥴링

### CPU스케쥴링

CPU 스케쥴러는 프로세스가 생성된 후 종료될 때까지의 모든 상태 변화를 조정하는 역할을 한다. 식당으로 비유하자면 CPU는 요리사이고 CPU 스케쥴러는 식당 관리자라고 볼 수 있다.

CPU 스케쥴링은 규모에 따라 고수준, 중간 수준, 저수준 스케쥴링으로 나뉜다.

![](https://t1.daumcdn.net/cfile/tistory/992539335C32270D34)

#### 고수준 스케쥴링

고수준 스케쥴링에서는 전체 시스템의 부하를 고려하여 작업을 시작할지 말지를 결정한다. 이 결정에 따라 시스템의 전체 프로세스 수가 결정되는데 이를 멀티프로그래밍 정도(degree of multiprogramming)라고 한다. 고수준 스케쥴링은 메인프레임과 같은 큰 시스템에서 규모가 큰 일괄 작업을 처리할 때 사용된다.

#### 중간 수준 스케쥴링

시스템의 부하를 조절하려면 고수준 스케쥴링 대신 중간 수준 스케쥴링을 고려해야 한다. 시스템에 이미 과부하가 걸려서 전체 프로세스 수를 조절해야 한다면 이미 활성화된 프로세르 중 일부를 보류 상태로 보낸다. 보류된 프로세스는 처리 능력에 여유가 생기면 다시 활성화 된다.

#### 저수준 스케쥴링

저수준 스케쥴링에서는 실제로 작업이 이루어진다. 오늘날의 CPU 스케쥴러는 대부분 중간 수준 스케쥴링과 저수준 스케쥴링으로 구성되어 있다. CPU 스케쥴러는 필요에 따라 준비 상태에 있는 프로세스를 실행 상태로 옮기기도 하고, 대기 상태로 보내기도 하며, 타임아웃으로 준비 상태로 돌려보내기도 한다.

### 스케쥴링의 목적

- 공평성 : 모든 프로세스가 자원을 공평하게 할당받아야 하며, 자원 할당 가정에서 특정 프로세스가 배제되어서는 안된다.
- 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 스케쥴링을 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 한다.
- 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호해야 한다.
- 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치해야 한다. 또한 시스템 자원이 늘어나는 경우 이 혜택이 시스템에 반영되게 해야 한다.
- 반응 시간 보장 : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
- 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되어서는 안 된다.

### 선점형 스케쥴링과 비선점형 스케쥴링

- 선점형 스케쥴링 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케쥴링 방식이다.
- 비선점형 스케쥴링 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케쥴링 방식이다.

| 구분      | 선점형                                                              | 비선점형                                                     |
| --------- | ------------------------------------------------------------------- | ------------------------------------------------------------ |
| 작업 방식 | 실행 상태에 있는 작업을 중단시키고 새로운 작업을 실행할 수 있다.    | 실행 상태에 있는 작업이 완료될 때까지 다른 작업이 불가능하다 |
| 장점      | 프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합하다 | CPU 스케쥴러의 작업량이 적고 문맥 교환의 오버헤드가 적다.    |
| 단점      | 문맥 교환의 오버헤드가 많다.                                        | 기다리는 프로세스가 많아 처리율이 떨어진다.                  |
| 사용      | 시분할 방식 스케쥴러에 사용된다.                                    | 일괄 작업 방식 스케쥴러에 사용된다.                          |
| 중요도    | 높다.                                                               | 낮다.                                                        |

### 프로세스 우선순위

프로세스는 중요도 별로 우선순위가 다르게 설정되어 우선순위가 높은 프로세스가 더 빨리 자주 실행된다. 프로세스는 크게 커널 프로세스와 일반 프로세스로 나뉘는데 커널 프로세스의 우선순위가 일반 프로세스보다 높다. 일반 프로세스들도 중요도에 따라 우선순위가 다르다.

### 프로세스의 분류에 따른 우선순위

#### CPU 집중 프로세스 vs 입출력 집중 프로세스

CPU를 할당받아 실행하는 작업을 CPU 버스트라고 하고, 입출력 작업을 입출력 버스트 라고 부른다.

- CPU 집중 프로세스 : 수학 연산과 같이 CPU를 많이 사용하는 프로세스를 말한다. 즉 CPU 버스트가 많은 프로세스이다.
- 입출력 집중 프로세스 : 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스를 말한다. 즉 입출력 버스트가 많은 프로세스이다.

입출력 집중 프로세스는 CPU 집중 프로세스에 비해 CPU를 사용하는 시간이 짧으므로 스케쥴링을 할 때 우선순위를 높게 주는게 시스템 효율에 좋다.

#### 전면 프로세스 vs 후면 프로세스

- 전면 프로세스 : GUI를 사용하는 운영체제에서 화면의 맨 앞에 높인 프로세스를 말한다. 현재 입력과 출력을 사용하는 프로세스이며, 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 한다.
- 후면 프로세스 : 사용자와 상호작용이 없는 프로세스이다. 압축 프로그램처럼 사용자의 입력이 없어도 작동하기 때문에 일괄 작업 프로세스라고도 한다.

전면 프로세스는 사용자의 요구에 즉각 반응해야 하지만 후면 프로세스는 상호작용이 없으므로 전면 프로세스의 우선순위가 높게 책정된다.

### 정리

![](https://yansigit.github.io/posts/cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/Untitled%205.png)

### 준비 상태의 다중 큐

우선순위가 서로 다른 프로세스들을 한 곳에 모아 놓으면 문맥교환이 일어날 때 마다 모든 PCB를 뒤져서 우선순위를 따져야 하므로 번거롭다. 이를 해결하기 위해 우선순위별로 큐를 만들어 두는데, 프로세스는 준비상태에 들어 올 때마다 자신의 우선순위에 해당하는 큐의 마지막에 삽입된다. 준비 큐를 몇 개로 나눌지, 나뉘어진 큐에 어떤식으로 CPU를 할당할지는 스케쥴링 알고리즘에 따라 달라진다.

![](https://velog.velcdn.com/images%2Fcheal3%2Fpost%2F095b6a02-522a-4d1d-9fb5-22fdec2fca0e%2Fimage.png)

- 고정 우선순위 방식 : 운영체제가 프로세스에 한번 우선순위를 부여하면 프로세스가 종료될 때 까지 변하지 않는다. 구현이 쉽지만 시스템의 변화에 대응하기 어려워 작업 효율이 떨어진다.

- 변동 우선순위 방식 : 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변할 수 있다. 구현이 어렵지만 시스템의 효율성을 높일 수 있다.

### 대기 상태의 다중 큐

입출력이 완료되기를 기다리는 프로세스들로 다중 큐를 사용하는데, 준비 상태의 다중 큐와 달리 대기 상태의 다중 큐는 같은 입출력을 요구한 프로세스끼리 모아놓는다.

![](https://velog.velcdn.com/images%2Fcheal3%2Fpost%2F8583e77e-58d5-4aaa-9f40-35d10117051c%2Fimage.png)

준비 상태의 다중 큐와 다른 점은 대기 상태의 다중 큐에 있는 프로세스들은 한번에 여러 개가 동시에 준비 큐로 이동한다는 점이다. 그리고 대기 상태의 다중 큐에 있는 PCB들도 기본적으로는 큐에 들어온 순서대로 이동하지만 나중에 들어온 PCB가 먼저 준비 상태로 옮겨 가는 경우도 있다.

![](https://yansigit.github.io/posts/cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/Untitled%208.png)

### 스케쥴링 알고리즘의 종류

| 구분              | 종류                                                                              |
| ----------------- | --------------------------------------------------------------------------------- |
| 비선점형 알고리즘 | FCFS 스케쥴링, SJF 스케쥴링, HRN 스케쥴링                                         |
| 선점형 알고리즘   | 라운드 로빈 스케쥴링, SRT 스케쥴링, 다단계 큐 스케쥴링, 다단계 피드백 큐 스케쥴링 |
| 둘 다 가능        | 우선순위 스케쥴링                                                                 |

### 스케쥴링 알고리즘의 평가 기준

- CPU 사용률 : 전체 시스템 동작 시간 중 CPU가 사용된 시간을 측정하는 방법이다.
- 처리량 : 처리량은 단위 시간당 작업을 마친 프로세스의 수로, 이 수치가 클수록 좋은 알고리즘이다.
- 대기 시간 : 프로세스가 생성된 후 실행되기 전까지 대기하는 시간
- 응답 시간 : 첫 작업을 시작한 후 첫 번쨰 출력이 나오기까지의 시간
- 반환 시간 : 대기 시간을 포함하여 실행이 종료될 때까지의 시간

![](https://blog.kakaocdn.net/dn/TS3DF/btrmKlB5bBm/MtnWsIdDmZXV2V4bmbbVI0/img.png)

스케쥴링 알고리즘의 성능을 비교할 때는 주로 평균 대기 시간을 본다.

### 비선점형 스케쥴링

|      | 동작방식                                                                   | 성능 | 평가                                                                            |
| ---- | -------------------------------------------------------------------------- | ---- | ------------------------------------------------------------------------------- |
| FCFS | 1개의 준비큐에 PCB가 들어온 순서대로 실행하는 FIFO 방식                    | 23ms | 처리시간이 긴 프로세스가 CPU를 차지하면 비효율적, 일괄 작업 시스템에서 비효율적 |
| SJF  | 준비 큐에 있는 프로세스 중에서 실행시간이 가장 짧은 작업부터 실행하는 방식 | 20ms | 운영체제가 프로세스의 종료 시간을 예측하기 어렵다, 공평하지못하다               |
| HRN  | 대기 시간+실행시간/실행시간을 우선순위로 책정하는 방식                     | 20ms | SJF 방식에서 발생할 수 있는 기아 현상을 해결하지만 여전히 공평하지 못하다       |

### 선점형 스케쥴링

|                  | 동작방식                                                                                                                                                                       | 성능    | 평가                                                                                                         |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------- | ------------------------------------------------------------------------------------------------------------ |
| 라운드 로빈      | FCFS 방식과 유사하나 프로세스별 time slice 개념이 추가됨                                                                                                                       | 22.33ms | time slice가 크면 FCFS와 다를 게 없고, 너무 작으면 문맥 교환 비용이 많이 발생하므로 적당한 크기를 찾아야한다 |
| SRT              | SJF에 time slice 개념 추가                                                                                                                                                     | 15.66ms | 여전히 기아 현상이 일어나고 문맥교환을 할 때 SJF에는 없는 추가적인 작업이 생김                               |
| 다단계 큐        | 고정된 우선순위별로 준비큐를 나누고 상위 우선순위의 큐가 모두 비워져야 다음 우선순위의 큐가 실행될 수 있음. 우선순위 별로 time slice를 다르게 설정해 효율을 높일 수 있음       |         |                                                                                                              |
| 다단계 피드백 큐 | 다단계 큐 방식과 동일하나 실행되어 본인의 time slice를 다 사용한 프로세스를 우선순위를 낮추는 방식으로 기아 현상 해결, 우선 순위가 낮을수록 할당되는 time slice의 크기가 크다. |         |                                                                                                              |

### 동기적 인터럽트

실행 중인 명령어로 발생하는 인터럽트

예)

- 프로그램상의 문제 때문에 발생하는 인터럽트
- 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트
- 입출력장치 같은 주변장치의 조작에 의한 인터럽트
- 산술 연산 중 발생하는 인터럽트

### 비동기적 인터럽트

실행중인 명령어와 무관하게 발생하는 인터럽트

예)

- 하드디스크 읽기 오류
- 메모리 불량
- 키보드 인터럽트
- 마우스 인터럽트

### 인터럽트 처리과정

인터럽트는 해당 인터럽트를 식별할 수 있는 IRQ(Interrupt Request)와 인터럽트가 일어났을 때 실행할 Interrupt Handler로 구성되어 있고, 그 인터럽트들의 IRQ와 발생 여부를 쌍으로 갖는 자료구조인 인터럽트 벡터가 존재한다.

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcToFdYrdCx8uB9-y60gGSojPaiFDfP1rIDNog&usqp=CAU)

인터럽트가 발생하게 되면,

1. 현재 실행중인 프로세스는 일시 정지 상태가 되며, 재시작을 위해 프로세스 관련 정보를 임시 저장한다.
2. 인터럽트 컨트롤러가 실행되고 여러개의 인터럽트가 발생했을 경우 인터럽트 우선순위를 고려하여 처리순서를 결정한다.
3. 인터럽트 벡터에 저장된 IRQ와 Interrupt Handler를 통해 결정된 순서대로 인터럽트들을 처리한다.
4. 프로세스는 해당 인터럽트 처리가 끝나면 인터럽트 종료에 따라 프로세스를 다시 시작되거나 종료된다.

### 이중모드(Dual Mode)

사용자가 자원에 직접 접근하면 야기할 수 있는 문제들로 인해 시스템은 커널 모드와 사용자 모드로 나뉜다. 커널 프로세스가 실행되는 상태를 커널 모드, 사용자 프로세스가 실행되는 상태를 사용자 모드라고 하는데, 사용자가 자원을 이용하기 위해 System Call을 통하는 등의 방식으로 커널모드로 전환되면 해당 작업을 마치고 복귀하지만 잘못된 메모리 영역 접근 등으로 발생한 인터럽트를 통해 커널 모드로 전환되면 해당 프로세스는 강제 종료된다.

---

질문거리

CPU 스케쥴링을 하는 이유가 뭔가요?
선점형 스케쥴러와 비선점형 스케쥴러의 차이가 뭔가요?
준비 상태의 다중큐와 대기 상태의 다중큐의 차이점이 뭘까요?
스케쥴러의 성능은 어떤식으로 측정하나요?
선점형 스케쥴러 알고리즘 중에서 하나만 들어서 아는대로 설명해주세요
기아 현상이 발생하는 원인에 대해서 설명해주세요
프로그램 창의 최대화 버튼을 클릭했을 때 일어나는 일을 인터럽트 관점에서 설명해주세요
이중모드에 대해서 설명해주세요

(심화) 다수의 CPU에 대해 스케쥴링을 실행할 경우 발생할 수 있는 문제점?
-> 캐시일관성 : 1번 CPU에서 실행되던 프로세서가 실행을 중단하고 2번 CPU에서 실행될 때 지연쓰기(write-back) 때문에 CPU간 캐시가 일치하지 않는 문제
