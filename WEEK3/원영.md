# 스케줄링

> CPU 스케줄링은 어떤 작업에 CPU를 배정할지를 결정하는 것을 말한다.

<br />

## 고수준 스케줄링

고수준 스케줄링은 전체 시스템의 부하를 고려하여 가장 큰틀에서 작업을 시작할지 말지를 결정한다.

이 결정에 따라 시스템의 전체 프로세스 수가 결정되는데 이를 _멀티프로그래밍 정도_ 라고 한다.

<br />

## 중간 수준 스케줄링

중간 수준 스케줄링은 중지(suspend)와 활성화(active)로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다.

<br />

## 저수준 스케줄링

어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정한다.

<br />

## 스케줄링의 목적

- 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 한다.
- 효율성 : 시스템 자원이 유휴시간 없이 사용되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 준다.
- 안정성: 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 행위로부터 보호한다.
- 확장성: 프로세스가 증가해도 시스템이 안정적으로 작동하도록 해야 한다.
- 반응 시간 보장 : 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
- 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되어서는 안된다.

<br />

## 선점형 스케줄링과 비선점형 스케줄링

- 선점형 스케줄링 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
- 비선점형 스케줄링 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식

| 구분      | 선점형                                                               | 비선점형                                                      |
| --------- | -------------------------------------------------------------------- | ------------------------------------------------------------- |
| 작업 방식 | 실행 상테에 있는 작업을 중단하고 새로운 작업을 실행할 수 있다.       | 실행 상태에 있는 작업이 완료될 때까지 다른 작업이 불가능하다. |
| 장점      | 프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합하다. | CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적다.     |
| 단점      | 문맥 교환의 오버헤드가 많다.                                         | 기다리는 프로세스가 많아 처리율이 떨어진다.                   |
| 사용      | 시분할 방식 스케줄러에 사용된다.                                     | 일괄 작업 방식 스케줄러에 사용된다.                           |
| 중요도    | 높다.                                                                | 낮다.                                                         |

<br />

## 프로세스 우선순위

대부분의 CPU 스케줄러는 우선순위를 사용한다.

우선순위가 높다는건 더 빨리 더 자주 실행된다는 뜻

커널 프로세스 > 일반 프로세스

<br />

## CPU 집중 프로세스와 입출력 집중 프로세스

프로세스가 CPU를 할당 받아 실행하는 작접을 _CPU 버스트_, 입출력 작업을 _입출력 버스트_ 라고 한다.

- CPU 집중 프로세스 : 수학 연산과 같이 CPU를 많이 사용하는 프로세스를 말한다. -> CPU 버스트가 많은 프로세스
- 입출력 집중 프로세스 : 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스를 말한다 -> 입출력 버스트가 많은 프로세스

CPU 집중 프로세스보다 입출력 집중 프로세스를 먼저 실행상태로 옮기는 것이 효율적이다.

이런 경우를 사이클 훔치기 라고 한다.

<br />

## 전면 프로세스와 후면 프로세스

- 전면 프로세스 : GUI 를 사용하는 운영체제에서 화면에 맨 앞에 놓인 프로세스를 말한다. 현재 입/출력을 사용하는 프로세스이며, 사용자와 상호작용이 가능한 상호작용 프로세스라고도 한다.
- 후면 프로세스 : 사용자와 상호작용이 없는 프로세스이다. 사용자의 입력 없이 작동하기 때문에 일괄 작업 프로세스라고도 한다.

<br />

## 정리

| 우선순위 높음        | 우선순위 낮음      |
| -------------------- | ------------------ |
| 커널 프로세스        | 일반 프로세스      |
| 전면 프로세스        | 후면 프로세스      |
| 대화형 프로세스      | 일괄 처리 프로세스 |
| 입출력 집중 프로세스 | CPU 집중 프로세스  |

<br />

## 다중 큐

<br />

### 준비상태의 다중 큐

프로세스는 저마다 중요도가 다르며 프로세스의 중요도는 PCB에 표시된다.

CPU 스케줄러는 모든 PCB를 뒤져서 가장 높은 우선순위의 프로세스에 CPU를 할당한다.

프로세스의 우선순위를 배정하는 방식에는 _고정 우선순위(static priority)_ 방식과 _변동 우선순위(dynamic priority)_ 이 있다.

- 고정 우선순위 방식 : 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식
- 변동 우선순위 방식 : 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식

<br />

### 대기 상태의 다중 큐

대기 상태에서도 다중 큐를 사용한다. 대기 상태는 입출력이 완료되기를 기다리는 프로세스가 모여 있는 곳이다.

대기 큐는 여러개의 PCB 를 동시에 꺼내어 준비 상태로 옮긴다.

<br />

## 스케줄링 알고리즘

| 구분              | 종류                                                                              |
| ----------------- | --------------------------------------------------------------------------------- |
| 비선점형 알고리즘 | FCFS 스케줄링, SJF 스케줄링, HRN 스케줄링                                         |
| 선점형 알고리즘   | 라운드 로빈 스케줄링, SRT 스케줄링, 다단계 큐 스케줄링, 다단계 피드백 큐 스케줄링 |
| 둘 다 가능        | 우선순위 스케줄링                                                                 |

<br />

### 스케줄링 알고리즘의 선택 기준

스케줄링 알고리즘의 성능을 비교할 때는 주로 평균 대기 시간을 본다.

```js
  // 평균 대기 시간
  모든 프로세스의 대기 시간 / 프로세스의 수
```

- CPU 사용률 : 전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법
- 처리량 : 처리량은 단위 시간당 작업을 마친 프로세스의 수, 이 수치가 클수록 좋은 알고리즘
- 대기 시간 : 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간, 짧을수록 좋다.
- 응답 시간 : 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 떄까지 걸리는 시간, 짧을수록 좋다.
- 반환 시간 : 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간, 반환시간은 대기 시간과 실행 시간을 더한 값

<br />

### FCFS 스케줄링(First Come First Served)

준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식, 선입선출 스케줄링이라고도 한다.

FCFS 는 단순하고 공평하지만 처리 시간이 긴 프로세스가 CPU를 차지하면 뒤에 다른 프로세스들은 하염없이 기다리기만 해서 시스템의 효율성이 떨어진다.

이를 _콘보이 효과(convoy effect)_ 라고 한다.

<br />

### SJF 스케줄링(Shortest Job First)

준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식으로, 최단 작업 우선 스케줄링이라고도 한다.

SJF 스케줄링은 프로세스의 종료 시간을 파악하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않는다.

SJF 스케줄링의 단점

- 프로세스의 종료 시간을 정확하게 예측하기 어렵다.
  - 프로세스가 운영체제에게 자신의 작업 시간을 알려주어 해결할 수 있다.
- 공평하지 못하다.
  - 에이징 방식으로 완화할 수 있다.( 순서를 한번 양보할때마다 카운트가 +1 되고 카운트가 리밋에 도달하면 무조건 실행되도록 하는 방식)

<br />

### HRN 스케줄링(Highest Response Ratio Next)

SJF 스케줄링의 아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘으로, 최고 응답률 우선 스케줄링이라고도 한다.

실행시간이 짧은 프로세스의 우선순위를 높게 설정하면서도 대기 시간을 고려하여 아사 현상을 완화한다.

SJF 스케줄링과 비교하면 대기 시간이 긴 프로세스가 우선순위를 높임으로써 CPU를 할당받을 확률이 높지만 여전히 공평성이 위배되어 잘 사용하지 않는다.

<br />

### 라운드 로빈 스케줄링(Round Robin, RR)

_순환 순서 방식_ 이라고도 하는 라운드 로빈 스케줄링은

한 프로세스가 할당받은 시간(타임 슬라이스)동안 작업을 하다가 작업을 완료하지 못하면

준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식이다.

FCFS 스케줄링 방식과 유사하나 차이점은 각 프로세스마다 CPU를 사용할 수 있는 최대 시간, 즉 타임 슬라이스가 있다는 것이다.

자신에게 주어진 타임 슬라이스 동안만 작업할 수 있으며, 작업이 다 끝나지 않으면 큐의 뒤쪽(tail) 에 다시 삽입된다.

라운드로빈은 우선순위가 적용되지 않은 가장 단순한 선점형 방식이다.

### 타임 슬라이스의 크기와 문맥 교환

- 타임 슬라이스가 큰 경우 : 타임 슬라이스가 무한대이면 FCFS 스케줄링이 된다.
- 타임 슬라이스가 작은 경우 : 컨텍스트 스위칭이 자주 발생해서 성능이 떨어진다.

<br />

### SRT 우선 스케줄링(Shortest Remaining Time)

SJF 와 라운드로빈을 혼합한 방식으로 _최소 잔류 시간 우선 스케줄링_ 이라고도 한다.

SJF 스케줄링의 선점형 버전이다.

SRT 스케줄링은 기본적으로 라운드 로빈 방식을 사용하지만 CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업 시간이 가장 적은 프로세스를 선택한다.

SRT 스케줄링은 현재 실행중인 프로세스와 큐에 있는 프로세스의 남은 시간을 계속 비교하는 계산을 해야 하고 컨텍스트 스위칭이 일어나므로 잘 사용하지 않는다.

<br />

### 우선순위 스케줄링

프로세스는 중요도에 따라 우선순위(priority)를 갖는데 이러한 우선순위를 반영한 스케줄링 알고리즘을 말한다.

<br />

### 다단계 큐 스케줄링(multilevel queue)

우선순위에 따라 준비 큐를 여러개 사용하는 방식이다.

우선순위가 높은 큐에 있는 모든 작업이 끝나야 다음 순위의 큐의 작업이 수행된다.

<br />

### 다단계 피드백 큐 스케줄링(multilevel feedback queue)

기본적으로 다단계 큐 스케줄링과 같은데, CPU를 사용하고 난 프로세스는 원래의 큐로 되돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어간다.

또 하나의 특징은 우선순위에 따라 타임 슬라이스의 크기가 다르다는 것이다.

프로세스가 우선순위가 낮아질수록 해당 큐의 타임 슬라이스가 커진다.

다단계 피드백 큐의 가장 마지막 큐에 있는 (우선순위가 가장 낮은) 프로세스는 무한대의 타임 슬라이스를 가지는데

이는 즉 FCFS 스케줄링 방식으로 들어온 순서대로 작업을 마치는 방식으로 동작한다.

오늘날의 운영체제가 CPU 스케줄링을 위해 일반적으로 사용하는 방식이다.

<br />

## 인터럽트(Interrupt)

CPU가 프로그램을 실행하고 있는 도중 다른 일을 우선적으로 처리하고자 하여 끼어들어 CPU에게 알려주는 것
<br />

### 동기적 인터럽트와 비동기적 인터럽트

동기적 인터럽트는 사용자 인터럽트라고도 하며 다음과 같은 종류가 있다.

- 프로그램상의 문제 때문에 발생하는 인터럽트
- 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트
- 입출력장치 같은 주변장치의 조작에 의한 인터럽트
- 산술 연산 중 발생하는 인터럽트

비동기적 인터럽트는 하드디스크 읽기 오류, 메모리 불량과 같은 하드웨어적인 오류로 발생하는 인터럽트, 키보드,마우스 인터럽트

<br />

### 인터럽트의 처리 과정

1. 인터럽트가 발생하면 실행중인 현재 프로세스는 일시 정지 상태가 되고, 재시작하기 위해 현재 프로세스 관련 정보를 임시로 저장함.
2. 인터럽트 컨트롤러가 실행되어 인터럽트의 처리 순서를 결정한다. 이떄 인터럽트가 여러개라면 우선순위를 고려하여 중요한거부터 처리하도록 결정
3. 먼저 처리할 인터럽트가 결정되면 인터럽트 벡터에 등록된 인터럽트 핸들러가 실행된다.

- _인터럽트 핸들러_ : 인터럽트 처리를 위해 미리 정의된 함수

4. 인터럽트 벡터에 연결된 핸들러가 인터럽트 처리를 마치면 일시 정지된 프로세스가 다시 실행되거나 종료 된다.

<br />

### 인터럽트와 이중 모드

프로세스는 운영체제와 관련된 커널 프로세스가 실행되는 _커널 모드_ , 사용자 프로세스가 실행되는 _사용자 모드_ 로 나뉜다.

사용자 모드가 하드디스크 입출력, 프로세스 생성과 같은 커널의 기능을 사용하려면 시스템 콜을 해야 하는데 이와 같이 운영체제가

두 모드를 전환하며 일 처리를 하는 것을 _이중 모드(dual mode)_ 라고 한다.

q1. 책에는 설명이 없는것 같은데 아사현상이란?
