# CHAPTER 07 물리 메모리 관리

# 메모리 관리의 개요

- 메모리의 구조는 1B 크기로 나뉜다.
- CPU는 메모리에 있는 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터(MAR)를 사용한다.
- MAR에 필요한 메모리 주소를 넣으면 데이터를 메모리에서 가져오거나 메모리에 데이터를 옮길 수 있다.
- 폰노이만 구조의 컴퓨터에서 모든 프로그램은 메모리에 올라와야 실행이 가능하다.
- 메모리를 계층적 구조로 만들어 작업 속도를 올리고 가격을 낮추는 방법을 계층적 메모리 구조라고 한다.

### 메모리 관리의 이중성

프로세스 입장에서 작업의 편리함과 관리자 입장에서 관리의 편리함이 충돌을 일으키는 것

## 소스코드의 번역과 실행

### 컴파일러

소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행한다. C, Java 등이 이 방식으로 프로그램을 실행한다.

### 컴파일러의 목적

- **오류 발견**: 소스코드에서 오류를 발견하여 실행 시 문제가 없도록 하는 것이다.
    - 컴파일러는 오류를 찾기 위해 심벌 테이블을 사용한다.
    - 심벌 테이블은 변수 선업부에 명시한 각 변수의 이름과 종류를 모아놓은 테이블로, 선언하지 않은 변수를 사용하지는 않았는지, 변수에 다른 종류의 데이터를 저장하지는 않았는지 알 수 있다.
- **코드 최적화**: 소스코드에서 군더더기와 사용하지 않는 변수를 삭제하면 더욱 간결해져서 실행 속도가 빨라진다.
    - 실행하기 전에 코드를 점검하여 오류를 수정하고 최적화함으로써 작고 빠른 실행 파일을 만든다.

### 컴파일 과정

1. 소스코드 작성 및 컴파일
    - 사용자가 소스코드를 작성하고, 그 소스코드를 컴파일러로 일차로 번역하여 목적 코드를 만든다.
2. 목적 코드와 라이브러리 연결
    - 라이브러리에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일을 만든다.
3. 동적 라이브러리를 포함하여 최종 실행
    - 동적 라이브러리는 실행할 때 삽입되는 함수를 가진 라이브러리이다.

### 인터프리터

소스코드를 한 행씩 번역하여 실행한다. 자바스크립트, 베이직 등이 이 방식으로 프로그램을 실행한다.

### 컴파일러 VS 인터프리터

|  | 컴파일러 | 인터프리터 |
| --- | --- | --- |
| 변수 | 변수를 먼저 선언한 후 코드를 작성한다. | 변수를 선언할 필요가 없다. |
| 실행 | 컴파일 후 실행된다. | 한 줄씩 실행된다. |
| 장점 | 오류 찾기, 코드 최적화, 분할 컴파일에 의한 공동 작업이 가능하다. | 실행이 편리하다. |
| 사용 프로그램 | 대형 프로그램 | 간단한 프로그램 |

## 메모리 관리자의 역할

메모리 관리자: MMU(Memory Manage Unit)라는 하드웨어

가져오기, 배치, 재배치 작업을 수행한다.

### 가져오기 작업

**프로세스와 데이터를 메모리로 가져오는 작업**이다. 메모리 관리자는 사용자가 요청하면 프로세스와 데이터를 모두 메모리로 가져온다. 하지만 예외가 있다.

- 데이터의 일부만 가져와 실행하는 상황: 용량이 큰 동영상을 실행해야 하는데 메모리가 충분하지 않다면 동영상 플레이어를 먼저 가져와 실행하고 동영상 데이터는 필요할 때마다 수시로 가져와 실행하는 것이다.
- 사용자의 요청이 없더라도 데이터를 가져오는 상황: 메모리 관리자는 앞으로 필요할 것이라고 예상되는 데이터를 미리 가져오기도 한다.

### 가져오기 정책

프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 결정하는 정책이다. 프로세스가 요청할 때 메모리로 가져오는 것이 일반적인 방법이지만, 필요하다고 예상되는 데이터를 미리 가져오는 방법도 있다.

### 배치 작업

**가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업**이다. 배치 작업 전에 메모리를 어떤 크기로 자를 것인지가 매우 중요하다. 같은 크기로 자르느냐, 실행되는 프로세스의 크기에 맞게 자르느냐에 따라 메모리 관리의 복잡성이 달라진다. 이렇게 나누어진 메모리의 구역에 따라 프로세스와 데이터를 어떤 위치에 놓을지 결정하는 것이 바로 배치 작업이다.

### 배치 정책

가져온 프로세스를 메모리의 어떤 위치에 올려놓을지 결정하는 정책이다. 메모리를 같은 크기로 자르는 것을 페이징이라고 하며, 프로세스의 크기에 맞게 자르는 것을 세그먼테이션이라고 한다. 배치 정책은 페이징과 세그먼테이션의 장단점을 파악하여 메모리를 효율적으로 관리할 수 있도록 정책을 만드는 것이다. 이는 한정된 메모리를 효율적으로 사용하기 위한 것으로, 시스템의 효율을 좌우하는 매우 중요한 기준이다.

### 재배치 작업

새로운 프로세스를 가져와야 하는데 메모리가 꽉 찼다면 메모리에 있는 프로세스를 하드디스크로 옮겨놓아야 새로운 프로세스를 메모리에 가져올 수 있다. 이처럼 **꽉 차 있는 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보내는 작업**이 재배치 작업이다.

### 재배치 정책

메모리가 꽉 찼을 때 메모리 내에 있는 어떤 프로세스를 내보낼지 결정하는 정책이다. 앞으로 사용하지 않을 프로세스를 내보내면 시스템의 성능이 올라가지만 자주 사용할 프로세스를 내보내면 성능이 떨어진다. 앞으로 사용하지 않을 프로세스를 찾아서 내보내는 알고리즘을 교체 알고리즘이라고 한다.

# 메모리 주소

## 32bit CPU VS 64bit CPU

CPU의 비트는 한 번에 다룰 수 있는 데이터의 최대 크기를 의미한다.

|  | 32bit CPU | 64bit CPU |
| --- | --- | --- |
| ALU | 32bit를 처리할 수 있도록 설계 | 64bit를 처리할 수 있도록 설계 |
| 레지스터 크기 | 32bit | 64bit |
| 버스 크기 | 32bit | 64bit |
| 메모리 주소 범위 | 0~2^32-1번지 | 0~2^64-1번지 |
| 메모리 총 크기 | 약 4GB | 약 16,777,216TB |

## 절대 주소 VS 상대 주소

### 절대 주소

**실제 물리 주소**를 가리킨다. **메모리 관리자 입장**에서 바라본 주소이며, 메모리 주소 레지스터가 사용하는 주소이다. 즉, 컴퓨터에 꽂힌 램의 실제 주소를 말한다. **물리 주소 0번지부터 시작**한다. 이러한 주소 공간을 **물리 주소 공간**이라고 한다.

### 상대 주소

메모리 관리자는 절대 주소를 사용하지만 사용자 입장에서 절대 주소는 불편하고 위험하다.

- 절대 주소를 사용하면 매번 운영체제 영역을 확인해야 한다. → 운영체제가 업그레이드되면 그 이상의 주소 범위를 사용할 수도 있기 때문이다.
- 운영체제 영역의 주소가 사용자에게 노출되면 실수나 고의적인 조작으로 운영체제 영역을 침범할 수도 있다.

게다가 사용자 프로세스 입장에서 운영체제 영역은 어차피 사용할 수 없는 공간이다. 또한 운영체제의 절대 주소를 알 필요도 없다.

상대 주소는 **사용자 영역이 시작되는 번지를 0번지로 변경하여 사용하는 주소 지정 방식**이다. 상대 주소는 **사용자 프로세스 입장**에서 바라본 주소이며, **절대 주소와 관계없이 항상 0번지부터 시작**해서 편리하다. 이러한 주소 공간을 **논리 주소 공간**이라고 한다.

### 상대 주소를 절대 주소로 변환하는 과정

메모리 관리자는 사용자 프로세스가 상대 주소를 사용하여 메모리에 접근할 때마다 상대 주소값에 재배치 레지스터 값을 더하여 절대 주소를 구한다. 재배치 레지스터는 주소 변환의 기본이 되는 주소값을 가진 레지스터로, 메모리의 사용자 영역의 시작 주소값이 저장된다. 메모리 관리자가 재배치 레지스터를 사용하여 상대 주소를 절대 주소로 변환하기 때문에, 사용자 프로세스 입장에서는 메모리가 항상 0번지부터 시작하는 연속된 작업 공간으로 보인다.

### 상대 주소를 절대 주소로 변환하는 과정 예

1. 사용자 프로세스가 상대 주소 40번지에 있는 데이터를 요청한다.
2. CPU는 메모리 관리자에게 40번지에 있는 내용을 가져오라고 명령한다.
3. 메모리 관리자는 재배치 레지스터를 사용하여 상대 주소 40번지를 절대 주소 400번지로 변환하고 메모리 400번지에 저장된 데이터를 가져온다.

# 단일 프로그래밍 환경에서의 메모리 할당

## 메모리 오버레이

- **프로그램의 크기가 실제 메모리(물리 메모리)보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법**
- 하나의 메모리에 여러 프로그램을 겹겹이 쌓아놓고 실행하는 것을 말한다.
- 프로그램을 몇 개의 모듈로 나누고 필요할 때마다 모듈을 메모리에 가져와 사용한다.
- 전체 프로그램을 메모리에 올려놓고 실행하기에는 메모리의 크기가 작기 때문에 실행하는 데 필요한 중요한 모듈만 올려놓고 나머지는 필요할 때마다 메모리에 가져와 사용한다.
- **한정된 메모리에서 메모리보다 큰 프로그램의 실행이 가능하다.**
- **프로그램 전체가 아니라 일부만 메모리에 올라와도 실행이 가능하다. 프로그램은 개념적으로 한 덩어리이지만 일부만 가지고도 실행할 수 있다. 이는 메모리를 여러 조각으로 나누어 여러 프로세스에 할당할 수 있다는 의미이기도 하다.**

## 스왑

메모리 오버레이 이용 시, 메모리에 새로운 모듈을 가져올 때, 먼저 메모리에 올라온 다른 모듈을 어딘가에 보관해야 한다. 쉽게 생각하면 원래 메모리에 있던 모듈을 원래의 하드디스크 위치에 옮겨놓으면 되겠지만, 아직 작업이 끝나지 않았기 때문에 저장장치의 별도 공간에 보관해야 한다. 이처럼 **메모리에 모자라서 쫓겨난 프로세스를 모아두는 저장장치의 특별한 공간**을 스왑 영역이라고 부른다. 스왑 영역은 메모리 관리자가 관리한다.

메모리 오버레이에서 스왑을 이용하면, 사용자는 실제 메모리의 크기와 스왑 영역의 크기를 합쳐서 전체 메모리로 인식하고 사용할 수 있다. 즉, 사용자 입장에서 보면 실제 메모리만을 사용하는 것보다 속도는 느리지만, 실제 메모리의 크기에 상관없이 큰 프로그램을 실행할 수 있는 것이다.

- 스왑 인: 스왑 영역에서 메모리로 데이터를 가져오는 작업
- 스왑 아웃: 메모리에서 스왑 영역으로 데이터를 내보내는 작업

# 다중 프로그래밍 환경에서의 메모리 할당

참고: [[운영체제] 내부 단편화, 외부 단편화란? | 외부단편화 해결 방법](https://code-lab1.tistory.com/54)

메모리 분할 방식에는 가변 분할 방식과 고정 분할 방식이 있다. 현대 운영체제에서 메모리 관리는 기본적으로 고정 분할 방식을 사용하면서 일부분은 가변 분할 방식을 혼합하고 있다.

## 가변 분할 방식

- 프로세스의 크기에 따라 메모리를 나눈다.
- 프로세스의 크기에 맞게 메모리가 분할되므로 메모리 영역의 크기가 각각 다르다.
- 한 프로세스가 연속된 공간에 배치되기 때문에 연속 메모리 할당이라고 한다.

장점: 프로세스를 한 덩어리로 처리하여 하나의 프로세스를 연속된 공간에 배치한다.

단점: 메모리 관리가 복잡하다. 메모리 통합 등의 부가적인 작업이 필요하다.

### 외부 단편화

남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적이지 않기 때문에 발생한다. 메모리 배치 방식, 조각 모음을 통해 해결한다.

### 메모리 배치 방식

- 최초 배치: 단편화를 고려하지 않는 것으로, 프로세스를 메모리의 빈 공간에 배치할 때 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 프로세스를 배치하는 방법
- 최적 배치: 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 프로세스를 배치하는 방법
- 최악 배치: 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스를 배치하는 방법. 최적 배치와 정반대이다.

### 조각 모음

작은 프로세스가 작업을 마치고 메모리에서 나가면 그 공간이 조각으로 남아 쓸모없어질 확률이 크다. 이렇게 **단편화가 발생했을 때, 이미 배치된 프로세스를 옆으로 옮겨 빈 공간들을 하나의 큰 덩어리로 만드는 것**을 조각 모음이라고 한다. 즉, 서로 떨어져 있는 여러 개의 빈 공간을 합치는 것이다.

**순서**

1. 조각 모음을 하기 위해 이동할 프로세스의 동작을 멈춘다.
2. 프로세스를 적당한 위치로 이동한다. 프로세스가 원래의 위치에서 이동하기 때문에 프로세스의 상대 주소값을 바꾼다.
3. 이러한 작업을 다 마친 후 프로세스를 다시 시작한다.

## 고정 분할 방식

- 프로세스의 크기와 상관없이 메모리를 같은 크기로 나눈다.
- 큰 프로세스가 메모리에 올라오면 여러 조각으로 나뉘어 배치된다.
- 한 프로세스가 분산되어 배치되기 때문에 비연속 메모리 할당이라고 한다.

장점: 메모리 관리가 수월하다. 메모리 통합 같은 부가적인 작업을 할 필요가 없다.

단점: 쓸모없는 공간으로 인해 메모리 낭비가 발생할 수 있다. 즉, 일정하게 나누어진 공간보다 작은 프로세스가 올라올 경우 메모리 낭비가 발생한다.

### 내부 단편화

메모리 내 사용자 영역이 실행 프로그램보다 커서 프로그램의 사용 공간을 할당 후 사용되지 않고 남게 되는 현상

100MB로 분할된 메모리에 80MB의 프로세스를 실행시키면 20MB의 내부 단편화가 발생한다.

동일하게 분할되는 공간의 크기를 조절하여 내부 단편화를 최소화한다. 메모리를 얼마로 나누느냐에 관한 정답은 없다.

## 버디 시스템

- 가변 분할 방식의 단점인 외부 단편화를 완화하는 방법이다.
- 가변 분할 방식과 고정 분할 방식의 특징을 모두 가지고 있다.
- 가변 분할 방식처럼 메모리가 프로세스 크기대로 나뉘며, 고정 분할 방식처럼 하나의 구역에 다른 프로세스가 들어갈 수 없고, 메모리의 한 구역 내부에 조각이 생겨 내부 단편화가 발생한다.
- 비슷한 크기의 덩어리가 서로 모여 있어 통합하기 쉽기 때문에, 조각 모음을 하지 않아도 간단히 큰 덩어리를 만들 수 있다.
- 효율적인 공간 관리 측면에서 볼 때 고정 분할 방식과 버디 시스템은 비슷한 수준이다. 그러나 공간을 1/2로 나누어가면서 메모리를 배분하는 버디 시스템보다 모든 공간을 똑같은 크기로 나누는 고정 분할 방식이 메모리 관리 측면에서 더 단순하기 때문에 버디 시스템보다 고정 분할 방식이 더 많이 사용된다.