-----

Chapter07. 물리 메모리 관리

-----
### 01. 메모리 관리의 개요
시분할 시스템  
메모리 관리 시스템  
메모리 관리의 이중성  
계층적 메모리 구조  
컴파일러와 인터프리터의 동작  
컴파일러의 목적 : 오류 발견, 코드 최적화  
컴파일러와 인터프리터의 차이 : 변수선언 유무  
컴파일 과정 : 사용자 작성 코드 > 목적 코드 변환 > 라이브러리 연결 > 최종 실행 파일을 생성하여 실행  
메모리 관리자, 가져오기, 배치, 재배치

#### CPU 스케줄러  
프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정하는 일을 하는것

#### 스케줄링  
여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일

#### 스케줄링의 단계  
규모에 따라 고수준 스케줄링, 중간 수준 스케줄링, 저수준 스케줄링으로 구분

#### 고수준 스케줄링  
가장 큰 틀에서 이루어지는 CPU스케줄링  
어떤 작업을 시스템이 받아들일지 또는 거부할지 결정  
시스템 자원을 사용하기 때문에 기존 작업에 영향을 미침  
시스템 내에서 동시에 실행 가능한 프로세스의 총 개수가 정해지는 데에 영향

#### 중간수준 스케줄링  
고수준 스케줄링과 저수준 스케줄링 사이에 일어나는 스케줄링  
중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하 방지  
프로세스의 상태 중 보류 상태에 해당  
저수준 스케줄링이 원만하게 이루어지도록 하는 역할

#### 저수준 스케줄링  
가장 작은 단위의 스케줄링  
준비 상태에 있는 프로세스 중 하나를 골라 실행 상태로 보내고,  
실행 상태에 있는 프로세스를 대기 상태로 보내며,  
대기 상태의 프로세스를 준비 상태로 보내는 것

#### 스케줄링의 목적  
원래 목적은 모든 프로세스가 공평하게 작업하도록 하는 것  
즉 특정 프로세스가 시스템 자원을 독점하거나 파괴하는 것을 막기 위해 중요도에 따라 우선순위를 배정  
또한 시스템 자원을 효율적으로 배분하여 전체적인 시스템의 성능 향상과 확장성 고려

* 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 하며,  
자원 배정 과정에서 특정 프로세스가 배제되어서는 안됨  
* 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고,  
유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 함  
* 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 조치해야하고,  
시스템 자원이 늘어나는 경우 이 혜택이 시스템에 반영되도록 해야함  
* 반응 시간 보장 : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에  
시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 함  
* 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되어서는 안됨

#### 스케줄링 시 고려 사항

#### 선점형 스케줄링
어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식   
대부분의 저수준 스케줄러는 선점형 스케줄링 방식 사용  
* 장점 : 빠른 응답 시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합  
* 단점 : 문맥 교환 같은 부가적인 작업으로 인한 낭비  
ex) 인터럽트 처리

#### 비선점형 스케줄링
어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식  
CPU를 점유한 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전까지는 계속 실행됨  
* 장점 : 선점형 스케줄링보다 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비도 적음  
* 단점 : CPU 사용 시간이 긴 프로세스 때문에 전체 시스템의 처리율 떨어짐  
ex ) 과거의 일괄 작업 시스템

#### 프로세스 우선순위
CPU 스케줄러는 각 프로세스에 우선순위를 부여하는데 커널 프로세스의 우선순위가 일반 프로세스보다 높음  
일반 프로세스의 우선순위는 사용자가 조절 가능  
우선순위가 높은 프로세스가 CPU를 먼저, 더 오래 차지하게 됨

#### CPU 버스트  
프로세스가 대기상태 일 때 CPU를 할당 받아 실행하는 작업

#### 입출력 버스트  
프로세스가 실행상태 일 때 입출력을 요청 하는 작업

#### CPU 집중 프로세스  
수학 연산과 같이 CPU를 많이 사용하는 프로세스  
CPU 버스트가 많은 프로세스

#### 입출력 집중 프로세스  
저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스  
입출력 버스트가 많은 프로세스

#### CPU 집중 프로세스와 입출력 집중 프로세스 우선순위  
두개가 함께 있을 때는 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적  
입출력 집중 프로세스는 실행 상태로 가면 대기 상태로 옮겨지기 때문에  
다른 프로세스가 CPU를 사용할 수 있게 되지만  
CPU 집중 프로세스가 실행 상태로 가면 자신의 타임 슬라이스를 다 쓸 때까지  
다른 프로세스가 실행되지 못함
입출력 집중 프로세스가 CPU 집중 프로세스보다 실행 상태에 먼저 들어가는 경우를 사이클 훔치기 라고 함

#### 전면 프로세스  
GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스  
현재 입력과 출력을 사용하는 프로세스  
사용자와 상호작용이 가능
후면 프로세스의 보다 우선순위가 높음

#### 후면 프로세스  
사용자와 상호작용이 없는 프로세스  
압축 프로그램처럼 사용자의 입력 없이 작동

#### 우선순위 정리  
* 우선순위 높은 프로세스 : 커널 프로세스, 전면 프로세스, 대화형 프로세스, 입출력 집중 프로세스  
* 우선순위낮은 프로세스 : 일반 프로세스, 후면 프로세스, 일괄 작업 프로세스, CPU 집중 프로세스  
프로세스가 분명하게 구분되지 않는  
대화형 프로세스, 일괄 작업 프로세스, 입출력 집중 프로세스, CPU 집중 프로세스는  
우선순위를 고려하기 어려울 수 있음

#### 다중 큐

준비 상태의 다중 큐  
CPU 스케줄러는 모든 프로세스 제어 블록을 뒤져서 가장 높은 우선순위의 프로세스에 CPU를 할당하는데  
매번 모든 프로세스 제어 블록을 검색하면 번거롭기 때문에  
우선순위에 따라 여러 개의 큐를 만들면 편리함  
준비 큐를 몇 개로 나눌지, 여러 개의 준비 큐에 있는 프로세스 중 어떤 프로세스에 CPU를 할당할지  
결정하는 일은 스케줄링 알고리즘에 따라 달라짐

#### 프로세스의 우선순위를 배정하는 방식  
* 고정 우선순위 방식 :  
운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식  
구현하기 쉬움  
시스템의 변화에 대응하기 어려워 작업 효율이 떨어짐  
* 변동 우선순위 방식 :  
프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식  
구현하기 어려움  
시스템의 효율성 향상

반전 우선순위(priority inversion)  
프로세스의 낮은 우선순위를 높은 우선순위로 바꾸는 것  
변동 우선순위 방식  
시스템의 효율성 향상

대기 상태의 다중 큐  
시스템 내에는 다양한 종류의 입출력 장치가 있기 때문에  
대기 상태의 프로세스를 한곳에 모아놓으면 관리하기 불편  
때문에 같은 장치의 입출력을 기다리는 프로세스의 프로세스 제어 블록은  
동일한 입출력 큐에 모아둠  
프로세스 제어 블록이 큐에 삽입된 순서대로 처리되지만,  
일부는 나중에 들어온 프로세스 제어 블록이 먼저 준비 상태로 옮겨 가기도 함

준비 큐와 대기 큐 차이  
준비 큐 : 한 번에 하나의 프로세스를 꺼내어 CPU 할당  
대기 큐 : 여러 개의 프로세스 제어 블록을 동시에 꺼내 준비 상태로 옮김

#### 스케줄링 알고리즘
비선점형 알고리즘  
프로세스가 CPU를 할당받으면 작업이 끝날 때까지 CPU를 놓지 않음  
효율이 떨어져 현재는 거의 사용되지 않음  
종류 :  
FCFS 스케줄링, SJF 스케줄링, HRN 스케줄링, 우선순위 스케줄링

선점형 알고리즘  
시분할 시스템을 고려하여 만들어진 알고리즘  
어떤 프로세스가 CPU를 할당 받아 실행 중이라도 운영체제가 CPU를 강제로 빼앗을 수 있음  
종류 :  
라운드 로빈 스케줄링, SRT 스케줄링, 다단계 큐 스케줄링, 다단계 피드백 큐 스케줄링, 우선순위 스케줄링

스케줄링 알고리즘의 선택 기준  
CPU 사용률 :  
전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법  
가장 이상적인 수치는 100%  
실제로는 90%에도 못 미침  
처리량 :  
시스템이 정상적으로 작동한다면 일정 시간 후 작업이 끝남  
단위 시간당 작업을 마친 프로세스의 수  
수치가 클수록 좋음
대기 시간 :  
프로세스가 생성된 후 실행되기 전까지 대기하는 시간  
짧을수록 좋음  
응답 시간 :  
프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간  
짧을수록 좋음  
반환 시간 :  
대기 시간을 포함하여 실행이 종료될 때까지의 시간
반환 시간 = 대기시간 + 실행시간

사용률과 처리량은 계산하기 어렵기 때문에  
주로 대기 시간, 응답 시간, 반환 시간을 계산  
스케줄링 알고리즘의 성능을 비교할 때는 주로 평균 대기 시간을 봄  
평균 대기 시간 = 모든 프로세스의 대기 시간 합 / 프로세스의 수

실행 시간  
프로세스 작업이 시작된 후 종료되기까지의 시간

FCFS 스케줄링  
준비 큐에 도착한 순서대로 CPU 할당
비선점형 방식  
단순하고 공평하지만 효율성이 떨어짐 -> 콘보이 효과(convoy effect)  
선입선출 스케줄링

SJF 스케줄링  
준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU 할당  
비선점형 방식
FCFS 스케줄링의 콘보이 효과를 완화하여 시스템 효율성 향상  
최단 작업 우선 스케줄링  
단점 :  
운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어려움  
공평하지 못함  
결론적으로 프로세스의 종료 시간을 파악하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않음

HRN 스케줄링
프로세스의 실행 시간이 판단 기준이기 때문에 항상 적은 시간을 사용하는 프로세스에 우선권이 주어짐  
서비스를 받기 위해 기다린 시간과 CPU 사용 시간을 고려하여 스케줄링을 하는 방식  
비선점형 방식  
최고 응답률 우선 스케줄링  
공평성이 위배되어 많이 사용되지 않음

라운드 로빈 스케줄링  
한 프로세스가 할당받은 시간동안 작업을 하다가 작업을 완료하지 못하면  
준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식  
선점형 알고리즘 중 가장 단순하고 대표적인 방식  
프로세스들이 작업을 완료할 때까지 계속 순환하면서 실행  
FCFS 스케줄링과 유사하지만 각 프로세스마다 CPU를 사용할 수 있는 최대 시간,  
즉 타임 슬라이스가 있다는 것  
프로세스는 자신에게 주어진 타임 슬라이스 동안만 작업할 수 있으며,  
작업이 다 끝나지 않으면 큐의 뒤쪽에 다시 삽입  
우선순위가 적용되지 않은 가장 단순한 선점형 스케줄링 방식  
효과적으로 작동하려면 문맥 교환에 따른 추가 시간을 고려하여 타임 슬라이스를 적절히 설정해야함  
타임 슬라이스가 큰 경우 :  
너무 크면 하나의 작업이 끝난 뒤 다음 작업이 시작되는 것처럼 보임  
타임 슬라이스가 작은 경우 :  
사용자는 여러 프로그램이 동시에 실행되는 것처럼 느낌

타임 슬라이스는 되도록 작게 설정하되 문맥 교환에 걸리는 시간을 고려하여 적당한 크기로 하는 것이 중요

SRT 우선 스케줄링  
SJF 스케줄링과 라운드 로빈 스케줄링을 혼합한 방식  
최소 잔류 시간 우선 스케줄링  
SJF 스케줄링의 선점형 버전  
기본적으로

-----