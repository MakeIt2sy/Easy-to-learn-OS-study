# CHAPTER 06 교착 상태

# 교착 상태의 개요

- **2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만을 기다리며 작업을 더 이상 진행하지 못하는 상태**
- 시스템 자원, 공유 변수, 공유 파일, 응용 프로그램 등을 사용할 때 발생할 수 있다.

## 교착 상태 VS 아사 현상

| 아사 현상 | 운영체제가 잘못된 정책을 사용했거나 오류가 생겨 특정 프로세스의 작업이 지연되는 문제. 에이징으로 해결할 수 있다. |
| --- | --- |
| 교착 상태 | 여러 프로세스가 작업을 진행하다 보니 자연적으로 일어나는 문제. 정책상 잘못이나 오류가 없어도 발생한다. |

# 교착 상태 필요조건

교착 상태는 `**상호 배제, 비선점, 점유와 대기, 원형 대기**` 조건이 **`모두 충족`**되어야 발생한다. 이를 `식사하는 철학자 문제`로 비유하자면 다음과 같다.

참고: [식사하는 철학자 문제](https://ko.wikipedia.org/wiki/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94_%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4_%EB%AC%B8%EC%A0%9C)

철학자는 스파게티를 먹기 위해 양 옆의 포크를 동시에 들어야 한다. 이때 각각의 철학자가 왼쪽의 포크를 들고 그 다음 오른쪽의 포크를 들어서 스파게티를 먹는 알고리즘을 가지고 있으면, 다섯 철학자는 동시에 왼쪽의 포크를 들 수 있으나 오른쪽의 포크는 다른 철학자가 이미 가져간 상태이기 때문에 다섯 명 모두가 무한정 서로를 기다리는 교착 상태에 빠지게 될 수 있다.

![식사하는 철학자 문제 그림](https://upload.wikimedia.org/wikipedia/commons/7/7b/An_illustration_of_the_dining_philosophers_problem.png)

식사하는 철학자 문제 그림

## 상호 배제

- 포크는 한 사람이 사용하면 다른 사람이 사용할 수 없는 배타적인 자원이다.
- 교착 상태는 배타적인 자원을 여러 프로세스가 사용해야 하는 경우에 발생한다.

## 비선점

- 어떤 사람의 힘이 월등해서 옆 사람의 포크를 뺏을 수 있다면 교착 상태가 발생하지 않는다.
- 교착 상태는 비선점(non-preemtive) 자원을 사용할 때 발생한다.

## 점유와 대기

- 한 철학자가 왼쪽 포크와 오른쪽 포크를 모두 다 점유하거나, 반대로 두 자원을 다 기다리는 상태라면 교착 상태가 발생하지 않는다. 즉, 철학자간 음식을 먹는 순서를 정하면 교착 상태는 발생하지 않는다.
- 한 프로세스가 자원을 점유한 상태에서 다른 프로세스의 자원을 기다리면 서로 진행을 방해하는 상태가 되므로 교착상태가 발생한다.

## 원형 대기

- 식사하는 철학자들은 원형 식탁에서 식사를 한다. 원을 이룬다는 것은 선후 관계를 결정할 수 없어 문제가 계속 맴돈다는 의미이다. 점유와 대기를 하는 프로세스들이 원을 이루면 서로 진행을 방해하는 상태가 되므로 교착 상태가 발생한다.
- 만약 철학자들이 사각형 식탁에서 식사를 한다면 교착 상태가 발생하지 않는다. 식탁의 한쪽 끝에서부터 순서대로 철학자들이 식사를 하면 되기 때문이다.

<aside>
💡 상호 배제, 비선점은 임계구역과 관련이 있다. 임계구역을 보호하기 위해 잠금 장치를 사용하면 상호 배제와 비선점이 보장되기 때문에 교착 상태가 발생할 수 있다. 임계구역의 자원을 사용하는 스레드들이 점유와 대기, 원형 대기 상황에 처할 때 교착 상태가 발생한다.
`**잠금 장치 사용 + 점유와 대기 + 원형 대기 = 데드락**`

</aside>

# 교착 상태 해결 방법

예방, 회피, 검출과 회복 방법이 있다. 현대 운영체제는 교착 상태 검출과 회복 방식을 사용한다.

## 교착 상태 예방

- 교착 상태를 유발하는 네 가지 조건이 발생하지 않도록 무력화하는 방식이다.
- 실효성이 적어 잘 사용되지 않는다.
- 상호 배제, 비선점 예방 → 잠금 장치를 안 쓰면 자원 보호를 할 수 없다.
- 점유와 대기, 원형 대기 예방 → 프로세스 작업 방식을 제한하고 자원을 낭비한다.

### 상호 배제 예방

시스템 내에 있는 모든 배타적인 자원을 없애버린다. 시스템 내의 모든 자원을 공유할 수 있다면 교착 상태가 발생하지 않는다.

—> 상호 배제를 적용하지 않으면 자원을 보호할 수 없다. 식사하는 철학자 문제에서 포크 하나를 여러 철학자가 동시에 쓰는 것과 마찬가지이다.

### 비선점 예방

모든 자원을 빼앗을 수 있도록 만든다. == Lock을 선점 방식으로 만든다.

—> 우선순위가 높은 프로세스가 다른 프로세스들이 사용 중인 자원을 모두 빼앗아, 아사 현상을 일으킨다.

<aside>
💡 [멀티 레벨 피드백 큐](https://www.notion.so/CHAPTER-04-CPU-6a710089e0f946c5900b754d4da2f850)에서 우선순위가 가장 낮은 큐에 들어있는 스레드는 사실상 비선점 방식으로 운영된다. 만약 우선순위가 가장 낮은 큐가 비선점 방식이 아니라면, 이 큐에 있는 스레드들은 계속해서 우선순위가 높은 큐에 있는 스레드에게 자원을 뺏겨 자원을 사용하지 못하고 아사 현상에 빠지게 된다. (혼자 생각해봄)

</aside>

### 점유와 대기 예방

프로세스가 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 하는 방법이다. 프로세스는 시작 초기에 자신이 사용하려는 모든 자원을 한꺼번에 점유하거나, 모든 자원을 기다려야 한다. 자원에 대한 제약을 푸는 것이 아닌, 프로세스의 자원 사용 방식을 변화시킨다는 점에서 의미가 있다.

**단점**

- 프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어렵다.
- 자원의 활용성이 떨어진다.
- 많은 자원을 사용하는 프로세스가 적은 자원을 사용하는 프로세스보다 불리하다.
- 결국 일괄 작업 방식으로 동작한다.

### 원형 대기 예방

자원을 한 방향으로만 사용하도록 설정한다. 모든 자원에 숫자를 부여하고 숫자가 작은 자원을 잡은 상태에서 숫자가 큰 자원을 점유하는 것만 허용한다.

—> 점유와 대기 예방보다 완화된 방법이다.

**단점**

- 프로세스 작업 진행에 유연성이 떨어진다.
- 자원의 번호를 어떻게 부여할 것인지 애매하다.

## 교착 상태 회피

프로세스에 자원을 할당할 때 어느 수준 이상의 자원을 나누어주면 교착 상태가 발생하는지 파악하여 그 수준 이하로 자원을 나누어준다.

—> 안정 상태를 유지할 수 있는 범위 내에서만 자원을 할당한다.

### 은행원 알고리즘

- **각 프로세스의 가용 자원 ≥ 기대 자원 ? 안정 상태이기 때문에 자원 할당을 한다 : 불안정 상태이기 때문에 자원 할당을 하지 않는다**
→ **가용 자원이 기대 자원보다 크거나 같을 때만 자원을 할당한다.**
- 가용 자원: 전체 자원 - 모든 프로세스의 할당 자원. 시스템 내 현재 사용할 수 있는 자원의 수.
- 최대 자원: 각 프로세스가 선언한 최대 자원의 수
- 할당 자원: 각 프로세스에 현재 할당된 자원의 수
- 기대 자원: 최대 자원 - 할당 자원. 각 프로세스가 앞으로 사용할 자원의 수.

### 문제점

- 프로세스가 자신이 사용할 모든 자원을 미리 선언해야 한다.
- 시스템의 전체 자원 수가 고정적이어야 한다.
- 자원이 낭비된다.

## 교착 상태 검출

- 운영체제가 프로세스의 작업을 관찰하면서 교착 상태 발생 여부를 계속 주시하는 방법
- 교착 상태가 발견되면 이를 해결하기 위해 교착 상태 회복 단계를 밟는다.
- 교착 상태 해결 방법 중 가장 현실적이다.

### 타임아웃 이용

- 일정 시간동안 작업이 진행되지 않은 프로세스를 교착 상태가 발생한 것으로 간주하여 처리한다.
- 교착 상태가 자주 발생하지 않을 것이라는 가정 하에 사용한다.
- 대부분의 데이터베이스와 운영체제에서 선호한다.
- 특별한 알고리즘이 없어 쉽게 구현할 수 있다.
- 가벼운 교착 상태 검출이라고 부른다.
- 타임아웃이 일어날 때 “프로그램이 응답하지 않습니다” 창이 뜬다.

### 타임아웃 이용의 문제점

- 엉뚱한 프로세스가 강제 종료될 수 있다. 교착 상태 외의 다른 이유로 작업이 진행되지 못하는 모든 프로세스가 강제 종료될 수 있다.
- 모든 시스템에 적용할 수 없다. 하나의 운영체제 내에서 동작하는 프로세스들은 운영체제가 상태를 감시하면 된다. 하지만 여러 군데에 데이터가 나뉘어 있는 분산 데이터베이스 같은 경우는 원격지에 있는 프로세스의 응답이 없는 게 교착 상태 때문인지, 네트워크 문제 때문인지, 단순히 처리가 늦어지는 것인지 정확히 알 수 없다. 그러므로 타임아웃 방법을 적용하여 교착 상태를 파악하기 어렵다.

### 데이터베이스에서의 타임아웃 이용

타임아웃으로 데이터의 일관성이 깨지는 문제를 해결하기 위해 데이터베이스에서는 체크포인트와 롤백을 사용한다. 이 방식은 운영체제의 ‘특정 시점으로 복원’에도 사용된다.

- 체크포인트: 작업을 하다 문제가 발생하면 저장된 상태로 되돌아오기 위한 표시이다. 체크포인트를 설정하면 현재의 시스템 상태가 스냅샷이라는 이름으로 하드디스크에 저장된다.
- 롤백: 작업을 하다가 문제가 발생하여 과거의 체크포인트로 되돌아가는 것을 말한다. 롤백이 일어나면 저장된 스냅샷을 복원하여 시스템을 체크포인트 시점으로 되돌린다.

### 자원 할당 그래프 이용

참고: [Resource Allocation Graph (RAG) in Operating System](https://www.geeksforgeeks.org/resource-allocation-graph-rag-in-operating-system/)

- 자원 할당 그래프를 사용하면 시스템 내의 프로세스가 어떤 자원을 사용하고 있는지 혹은 기다리고 있는지를 알 수 있다.
- 자원 할당 그래프에 **`사이클`**이 발견되면 교착 상태가 검출된 것이다.

![https://media.geeksforgeeks.org/wp-content/uploads/Slide2.jpg](https://media.geeksforgeeks.org/wp-content/uploads/Slide2.jpg)

![https://media.geeksforgeeks.org/wp-content/uploads/Slide3.jpg](https://media.geeksforgeeks.org/wp-content/uploads/Slide3.jpg)

### 다중 자원을 사용하는 경우의 자원 할당 그래프 이용

하나의 자원을 여러 개의 프로세스가 동시에 사용할 수 있는 경우에는 교착 상태를 검출하기 복잡하다. 단순한 사이클 여부로는 판단할 수 없고, **대기 그래프와 그래프 감소 방법을 이용해서 사이클을 찾아야 한다.** 대기 그래프에서 그래프 감소를 완료한 후에도 사이클이 남아 있다면 교착 상태가 발생한 것으로 판단한다.

- 대기 그래프: 자원 할당 그래프에서 프로세스와 프로세스 간에 기다리는 관계만을 나타낸 그래프
- 그래프 감소: 대기 그래프에서 작업이 끝날 가능성이 있는 프로세스의 화살표와 관련 프로세스의 화살표를 연속적으로 지워가는 작업

## 교착 상태 회복

- 교착 상태를 유발한 프로세스를 강제로 종료한다.
- 강제 종료된 프로세스가 다시 실행되기 전에 시스템을 복구한다. (체크포인트 사용, 부하가 크다.)

### 프로세스를 강제로 종료하는 방법

- 교착 상태를 일으킨 모든 프로세스를 동시에 종료한다. 종료한 프로세스를 다시 실행할 때는 순차적으로 실행한다.
- 교착 상태를 일으킨 프로세스를 하나씩 골라 순서대로 종료한다. 프로세스가 종료될 때마다 나머지 프로세스의 상태를 파악한다.

# 질문 목록

### 은행원 알고리즘이 뭔가요?

- 은행원 알고리즘에서 언제 자원 할당을 하나요?

### 왜 현대 OS는 교착 상태 예방과 회피 기법을 사용하지 않나요?