# 물리 메모리 관리

### 메모리 관리의 복잡성과 이중성

- 메모리 관리의 복잡성 : 운영체제를 포함한 다수의 프로세스가 실행되는 과정에서 메모리를 점유하는데, 이런 메모리들을 메모리 관리 시스템(MMS)이 담당한다.
- 메모리 관리의 이중성 : 여러 프로세스가 메모리를 사용하는 과정에서 프로세스 입장에서의 작업의 편리함과, MMS 입장에서의 작업의 편리함이 충돌하는것을 메모리 관리의 이중성이라고 한다.

### 컴파일러와 인터프리터

| 종류       | 동작방식                                    | 사용언어             |
| ---------- | ------------------------------------------- | -------------------- |
| 컴파일러   | 소스코드를 기계어로 번역한 후 한꺼번에 실행 | Java, C 등           |
| 인터프리터 | 소스코드를 한 줄씩 번역하며 실행            | Javascript, Basic 등 |

#### 컴파일러를 사용하는 이유

- 오류 발견 : Symbol table 등을 사용해 프로그래머가 생각치 못한 각종 오류들을 찾는다.

- 코드 최적화 : 코드 전체를 파악한 후 사용하지 않은 변수가 선언된 부분을 삭제하는 등의 최적화를 진행한다.

#### 컴파일 과정

1. 소스코드 작성 및 컴파일 : 프로그래머가 작성한 소스코드를 기반으로 1차 번역 후 목적 코드를 얻는다.
2. 목적 코드와 라이브러리 연결 : 목적 코드에 라이브러리에 있는 코드를 삽입하여 최종 실행파일을 만든다.
3. 동적 라이브러리를 포함하여 최종 실행 : 목적 코드에 동적 라이브러리 포인터를 삽입해 프로그램을 실행한다.

### 메모리 관리자(MMU)의 역할

- fetch : 프로세스와 데이터를 메모리로 가져오는 작업이다. MMU는 사용자의 요청이 없더라도 앞으로 필요할 것이라고 예상되는 데이터를 미리 가져오기도 한다.

- placement : 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업이다. 여러가지 방식으로 메모리를 분할해 배치할 수 있다.

- replacement : 새로운 프로세스를 메모리로 가져와야 하는데 메모리가 포화상태일때 기존에 메모리를 점유하고 있던 오래된 프로세스를 내보내는 작업이다.

- fetch policy : 프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 결정하는 정책이다. 일반적으로는 요청할 때 가져오지만, 필요하다고 예상되는 데이터를 미리 가져오는 prefetch를 할 수도 있다.

- placement policy : 가져온 프로세스를 메모리의 어떤 위치에 올려놓을지 결정하는 정책이다. 고정 분할 방식과 가변 분할 방식을 통해 메모리 공간을 효율적으로 관리해야 한다.

- replacement policy : 메모리가 포화상태일때 어떤 프로세스를 내보낼 지 결정하는 정책이다. 자주 사용하는 프로세스를 내보내면 성능이 떨어지는 문제가 있다.

### 32bit CPU와 64bit CPU의 차이

| 종류      | 한번에 다룰 수 있는 최대 데이터 | 레지스터 크기 | 버스의 대역폭 | 인식할 수 있는 최대 메모리 |
| --------- | ------------------------------- | ------------- | ------------- | -------------------------- |
| 32bit CPU | 32bit                           | 32bit         | 32bit         | 4GB                        |
| 64bit CPU | 64bit                           | 64bit         | 64bit         | 1677만TB                   |

### 절대 주소와 상대 주소

| 구분      | 절대 주소                | 상대 주소                                |
| --------- | ------------------------ | ---------------------------------------- |
| 관점      | 메모리 관리자 입장       | 사용자 프로세스 입장                     |
| 주소 시작 | 물리 주소 0번지부터 시작 | 물리 주소와 관계없이 항상 0번지부터 시작 |
| 주소 공간 | 물리 주소(실제 주소)공간 | 논리 주소 공간                           |

#### 상대 주소를 절대 주소로 변환하는 과정

1. 사용자 프로세스가 상대 주소에 있는 데이터를 요청한다.
2. CPU는 메모리 관리자에게 해당 상대 주소에 있는 내용을 가져오라고 명령한다.
3. 메모리 관리자는 재배치 레지스터를 사용하여 상대 주소를 절대 주소(상대 주소 + 재배치 레지스터 값)로 변환하고 해당 주소에 저장된 데이터를 가져온다.

### 메모리 오버레이

실행하려는 프로그램의 전체 크기가 사용가능한 물리메모리보다 클 때 전체 프로그램을 한번에 메모리에 올리지 않고 여러개의 모듈로 분할해 필요에 따라 각 모듈을 메모리로 가져와 실행하는걸 메모리 오버레이(memory overlay)라고 한다.

메모리 오버레이를 사용함에 있어 다음과 같은 중요한 의미가 있다.

- 한정된 메모리에서 메모리보다 큰 프로그램의 실행이 가능해진다.

- 프로그램 전체가 아니라 일부만 메모리에 올라와도 실행이 가능하다.

### 스왑

메모리 오버레이가 일어날 때, 기존에 메모리에 올라와 있던 모듈이 저장장치의 **스왑 영역(swap area)**이라는 곳에 저장되는데 swap area로 모듈이 이동하는걸 swap out 이라고 하고, swap area에서 메모리로 다시 모듈이 이동하는걸 swap in 이라고 한다. swap area는 메모리에서 실행중이던 모듈이 임시적으로 저장되는 곳이기 때문에 저장장치 관리자가 아닌 메모리 관리자가 관리한다. 사용자는 메모리의 크기와 swap area의 크기를 합쳐서 사용가능한 메모리로 인식하는데, 이렇게 합쳐서 사용하게 되면 메모리만으로 동작할 때보다는 좀 더 느리다.

최대 절전 모드를 사용하게 되면 실행중이던 프로세스들이 스왑영역으로 이동하게 된다.

### 메모리 분할 방식

memory placement policy에 해당하며, 가변 분할 방식과 고정 분할 방식이 있다.

- 가변 분할 방식 : 메모리가 프로세스에 올라올 때 해당 프로세스의 크기 만큼의 영역을 찾아 그대로 저장하는 방식이다. 가변 분할 방식이라고도 한다.

- 고정 분할 방식 : 메모리가 프로세스에 올라올 때 해당 프로세스가 메모리에 정해진 크기보다 크면 분할 해 저장하는 방식이다. 고정 분할 방식이라고도 한다.

### 가변 분할 방식

프로세스의 크기에 맞게 분할되므로 메모리의 영역이 각각 다르다. 한 프로세스가 연속된 공간에 배치되기 때문에 연속 메모리 할당(contiguous memory allocation)이라고 한다.

#### 외부 단편화

세그멘테이션 기법에서는 프로세스별로 주어지는 메모리영역의 크기가 가변적이므로 남은 메모리 영역의 합이 실행하려는 프로세스보다 커도 메모리 영역이 여기저기 흩어져 있어 프로세스를 실행할 수 없는 상황이 발생하는데, 이를 외부 단편화(external fragmentation) 또는 조각화라고 한다.

이를 해결하기 위해 메모리 배치 전략(memory placement strategy)이나 조각 모음(defragmentation)을 사용한다. memory placement strategy는 작은 조각들이 발생하지 않도록 프로세스를 잘 고려해 배치하는 전략이며, defragmentation은 조각들이 발생했을 때 조각들을 모아서 합치는 작업이다. 전자는 선처리에 해당하고 후자는 후처리에 해당한다.

#### memory placement strategy

- first fit : 단편화를 고려하지 않는 것으로, 프로세스를 메모리의 빈 공간에 배치할 때 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 프로세스를 배치하는 방법이다.

- best fit : 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 프로세스를 배치하는 방법이다.

- worst fit : 메모리의 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스를 배치하는 방법이다.

first fit의 경우에는 메모리의 빈 공간을 모두 확인하지않아도 된다고 장점이 있고, best fit은 딱 맞는 공간을 찾을 경우 단편화가 일어나지 않지만 아닐 경우 아주 작은 조각을 만들 수 있는 단점이, worst fit은 프로세스가 배치되고 남은 공간이 충분히 커서 또 다른 프로세스를 배치할 수 있다는 장점이 있다.

#### defragmentation

어떤식으로 배치해도 단편화는 무조건 발생하게 되어있는데, 다음과 같이 진행된다.

1. 조각 모음을 하기 위해 이동할 프로세스를 잠시 멈춘다.
2. 프로세스를 적당한 위치로 이동시키고, 프로세스의 상대 주소값을 바꾼다.
3. 이동을 위해 멈춰놓은 프로세스를 다시 실행한다.

### 고정 분할 방식

프로세스의 크기에 상관없이 메모리가 같은 크기로 나뉘며, 큰 프로세스가 메모리에 올라오면 여러 조각으로 나뉘어 배치된다. 한 프로세스가 분산되어 배치되기 때문에 비연속 메모리 할당(noncontiguous memory allocation)이라고 한다.

#### 내부 단편화

페이징 기법도 단점이 있다. 일정하게 나뉜 메모리의 크기보다 작은 프로세스가 배치될 경우 낭비되는 공간이 생긴다는 것이다. 이처럼 각 메모리 조각에 프로세스를 배치하고 공간이 남는 현상을 내부 단편화(internal fragmentation)라고 한다.

내부 단편화는 후처리방식으로 해결할 수 없다. 따라서 내부 단편화가 발생하지 않도록 분할되는 메모리의 크기를 신중하게 결정하는 방법으로 해결한다.

| 구분   | 가변 분할 방식                     | 고정 분할 방식                     |
| ------ | -------------------------------- | -------------------------- |
| 특징   | 연속 메모리 할당                 | 비연속 메모리 할당         |
| 장점   | 프로세스를 한 덩어리로 관리 가능 | 메모리 관리가 편리         |
| 단점   | 빈 공간의 관리가 어려움          | 프로세스가 분할되어 처리됨 |
| 단편화 | 외부 단편화                      | 내부 단편화                |

### 버디 시스템(Buddy System)

가변 분할 방식의 단점인 외부 단편화를 완화하는 방법으로 Buddy System이 있다. 이는 Segmetation 기법이지만 고정 분할 방식과 유사한 점이 있다.

#### 작동방식

1. 전체 메모리를 2의 제곱수로 분할해 프로세스의 크기가 비슷하게 만들고 프로세스를 배치한다.
2. 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어간다.
3. 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다.

#### 특징

버디 시스템은 가변 분할 방식과 고정 분할 방식의 특징을 모두 가지고 있다. 내부 단편화와 외부 단편화가 모두 발생한다. 버디 시스템이 가변 분할 방식보다 효과적으로 공간을 관리할 수 있는 이유는 비슷한 크기의 덩어리가 서로 모여있어 통합하기가 쉽기 때문이다.

효율적인 공간 관리 측면에서 보면 Buddy System과 고정 분할 방식은 비슷하지만 고정 분할 방식이 메모리 관리 측면에서 더 단순하기 때문에 Buddy System보다 고정 분할 방식이 더 많이 사용되고 있다.

---

질문거리

- 컴파일러와 인터프리터는 어떻게 다른가요?
- 컴파일 과정이 어떻게 진행되는지 설명해주세요
- 메모리 관리자는 어떤 역할을 하나요?
- 메모리 계층 구조란 뭔가요?
- 정적 라이브러리와 동적 라이브러리의 차이점이 뭔가요?

-> 정적 라이브러리는 컴파일시에 해당 라이브러리의 코드가 목적 코드에 삽입되는 반면, 동적 라이브러리는 코드가 아니라 주소를 가리키는 포인터가 삽입됩니다. 동적 라이브러리를 사용하는 실행파일은 포인터가 가리키는 해당 라이브러리가 필요할 때만 로드하면 되고 필요한 코드가 메모리에 올라와 있으면 시간과 자원이 절약되지만, 반복적으로 해당 코드를 참조해야 하는 경우 오버헤드가 생겨 성능이 저하될 수 있습니다.

- 메모리 오버레이가 뭐고, 사용하는 이유가 뭔가요?
- 경계 레지스터와 재배치 레지스터는 어떻게 다른가요?
- 가변 분할방식과 고정 분할방식에 대해서 설명해주세요
- 내부 단편화와 외부 단편화의 차이가 뭔가요?
- 메모리 연속 할당 방식 3가지를 설명해주세요
- worst fit은 어떤 경우에 사용하면 좋을까요?
