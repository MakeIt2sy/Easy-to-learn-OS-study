# 가상 메모리의 기초

## 1. 가상 메모리의 개요
<br/>

### [가상 메모리 시스템]
 <br/>

  프로그램 크기가 메모리 크기보다 큰 경우를 커버하기 위해 오버레이 기법이 등장했지만, 오버레이된 프로그램을 위해서도 충분한 메모리를 갖추지 못한 경우에 똑같은 메모리 부족 오류가 발생하기 때문에 가상 메모리의 개념이 탄생했다. 

 <br/>

- 가상 메모리는 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식을 말한다. 프로그램을 실행하는 데에 필요한 최소한의 메모리만 로드하고 나머지는 하드디스크(스왑 영역)에 두어 현재 필요한 데이터만 가져오는 방식으로 작동한다.  
- 가상 메모리 시스템의 모든 프로세스는 물리 메모리와 별개로 0번지부터 시작하는 연속된 메모리 공간을 가지는데 이는 논리 주소와 유사하며 가상 주소라고 부른다. 가상 주소를 물리 주소로 변환하는 것을 동적 주소 변환(DAT)라고 한다. 
- 메모리 분할 방식에는 가변 분할 방식을 이용한 세그먼테이션, 고정 분할 방식을 이용한 페이징, 두 가지를 보완한 세그먼테이션-페이징 혼용기법이 있으며 세그먼테이션-페이징 혼용 기법을 주로 사용한다.

<br/>

### [매핑 테이블]
 <br/>

 - 가상 주소와 물리 주소를 일대일 매핑하여 테이블 형태로 관리하는 것을 매핑 테이블 이라고 한다. 

<br/>

## 2. 페이징 기법
<br/>

### [페이징 기법의 구현]
 <br/>

 페이징 기법은 고정 분할 방식을 이용한 가상 메모리 관리 기법으로, 물리 주소 공간을 같은 크기로 나누어 사용한다. 가상 주소에 있는 분할 영역 각각을 **페이지**라고 부르고 물리 메모리의 각 영역은 **프레임**이라고 부른다. 페이지 테이블은 어떤 페이지가 어떤 프레임에 있는지에 대한 정보를 담고 있고, 스왑 영역에 있는 페이지는 invalid 로 표시한다. 

 <br/>

### [페이징 기법의 주소 변환]
 <br/>

 페이징 기법에서는 가상 주소를 VA=<P,D>로 표현하는데, VA는 가상주소, P는 페이지, D는 페이지의 처음 위치에서 해당 주소까지의 거리를 의미한다.  
 물리 주소는 PA=<F,D> 로 표현하며 PA는 물리 주소, F는 프레임, D는 프레임 처음 위치에서 해당 주소까지의 거리를 의미한다.   

 <br/>

 **주소 변환 과정**

 1) 가상 주소를 <P,D> 로 변환한다. (P는 가상 주소를 페이지 크기로 나눈 몫, D는 그 나머지)  
 2) 페이지 테이블을 이용해 물리 주소로 변환한다. 

<br/>

### [페이지 테이블 관리]
 <br/>

- 시스템 내에는 여러 개의 프로세스가 존재하고 프로세스마다 하나의 페이지 테이블이 있기 때문에 전체 페이지 테이블의 크기는 프로세스의 수에 비례해서 커진다. 
- 페이지 테이블은 메모리 관리자가 자주 사용하는 자료 구조이기 때문에 운영체제 영역의 일부분에 모아놓는다. 페이지 테이블의 크기가 늘어나면 그만큼 운영체제 영역이 늘어나 사용자 영역이 줄어든다. 

<br/>

### [페이지 테이블 매핑 방식]
 <br/>

 - 직접 매핑 : 모든 페이지 테이블을 물리 메모리에 가지고 있는 방식. 별다른 부가 작업 없이 바로 주소 변환이 가능하기 때문에 직접 매핑이라고 부른다. 
 - 연관 매핑 : 전체 페이지 테이블을 스왑 영역에 두고 그 중 일부만 물리 메모리에 가지고 있는 방식. 물리적 메모리의 여유 공간이 작을 때 사용하는 방식이다. 물리 메모리에 있는 그 일부 테이블을 변환 색인 버퍼(TLB) 혹은 연관 레지스터라고 부른다. 전체 페이지 테이블이 스왑 영역에 있어 메모리를 절약할 수 있지만 TLB 미스가 많으면 시스템 성능이 떨어진다. 또 테이블 일부를 무작위로 가지고 있기 때문에 모든 TLB 검색 후에야 TLB 미스를 알 수 있다는 문제가 있다. 
 - 집합-연관 매핑 : 연관 매핑의 문제를 개선한 방식. 페이지 테이블의 일부만 물리 메모리 공간에 가져오는 방식은 동일하나 무작위로 가져오지 않고 일정한 집합을 자른 덩어리를 가져오기 때문에 시간이 단축된다. 
 - 역매핑 : 프레임 번호를 기준으로 테이블을 구성하는 방식. 프레임을 기준으로 어떤 프로세스가 어떤 페이지에 올라가 있는지를 표시한다. 프로세스의 수와 상관없이 테이블이 하나만 존재한다. 그러나 프로세스가 가상메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 한다는 단점이 있다. 

<br/>

## 3. 세그먼테이션 기법
<br/>

### [세그먼테이션 기법의 구현]
 <br/>

 세그먼테이션 기법은 가변 분할 방식을 이용한 가상 메모리 관리 기법으로, 물리 메모리를 프로세스 크기에 따라 가변적으로 나누어 사용한다. 페이징 기법과 마찬가지로 매핑 테이블을 이용하는데 세그먼테이션 테이블에는 세그먼트의 크기를 나타내는 **리밋**과 물리 메모리상의 시작 주소를 나타내는 **어드레스**가 있다.

  메모리를 프로세스 단위로 관리하기 때문에 페이지 테이블은 작고 단순하지만 외부 단편화 때문에 메모리 관리가 복잡하다는 단점이 있다. 

<br/>

### [세그먼테이션 기법의 주소 변환]
 <br/>

 가상 주소를 VA=<S,D> 로 표현하는데 S는 세그먼트 번호, D는 세그먼트 시작 지점에서 해당 주소까지의 거리를 의미한다. 변환 방식은 페이징 방식과 유사하다.  

 ** 트랩 : 자신의 영역을 벗어나는 주소에 접근하려고 할 때 발생하는 일종의 인터럽트


<br/>

## 4. 세그먼테이션-페이징 혼용 기법
<br/>

  페이징 기법과 세그먼테이션은 각각 장단점이 있다. 페이징 기법은 메모리 관리가 수월하지만 테이블 크기가 크고, 세그먼테이션 기법은 테이블 크기가 작지만 외부 단편화 때문에 추가적인 관리가 필요하다. 그리하여 둘의 장점만 취한 세그먼테이션-페이징 혼용 기법이 등장하였다. 

<br/>

### [메모리 접근 권한]
 <br/>

 메모리 특정 번지에 저장된 데이터를 사용할 수 있는 권한으로 읽기, 쓰기, 실행, 추가 4가지가 있다. 메모리 접근 권한 검사는 가상 주소에서 물리 주소로 변환이 일어날 때마다 시행된다. 페이징이든 세그먼테이션이든 매핑 테이블에 이러한 메모리 접근 권한에 대한 정보를 가지고 있으며, 주소 변환이 일어날 때마다 검사한다. 

<br/>

### [세그먼테이션-페이징 혼용 기법의 도입]
 <br/>

  페이징 기법에서 페이지는 각각 접근 권한이 다르기 때문에 페이지 테이블의 모든 행에는 메모리 접근 권한에 대한 권한 비트가 추가되고 이 때문에 테이블의 크기는 커진다. 인접한 페이지의 메모리 접근 권한이 같은 경우가 많은데도 페이지마다 권한 비트를 설정하면 메모리를 낭비하게 된다.  
  세그먼테이션 테이블을 이용하면 이 문제를 해결할 수 있다. 페이지로 분할된 가상 주소 공간에서 서로 관련 있는 영역을 하나의 세그먼트로 묶어 세그먼테이션 테이블로 관리하고 각 세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리하는 방식이다. 각 세그먼테이션 테이블은 자신과 연결된 페이지 테이블의 시작 주소를 가진다. 이와 같이 페이징 기법에 세그먼테이션 테이블을 추가하고, 권한 비트와 같이 중복되는 데이터를 세그먼테이션 테이블로 옮겨 오면 테이블 크기를 줄일 수 있다. 

### [세그먼테이션-페이징 혼용 기법의 주소 변환]
 <br/>
  
  세그먼테이션-페이징 혼용 기법에서는 가상주소를 VA=<S,P,D>로 표현한다. S는 세그먼트 번호, P는 페이지 번호, D는 페이지 처음 위치에서 해당 주소까지의 거리를 의미한다. 이는 페이징 기법 가상주소에서 세그먼트 번호가 추가된 것이다. 

 <br/>

 **주소 변환 과정**

  1) 사용자가 어떤 주소에 있는 데이터를 요청하면 해당 주소가 몇 번째 세그먼트의 몇 번째 페이지로부터 얼마나 떨어져 있는지 계산하여 가상 주소 VA=<S,P,D>를 구한다.  
  2) 세그먼테이션 테이블에서 불법 접근은 아닌지 확인하고 주어진 메모리 영역을 벗어나면 트랩을 발생시켜 프로세스를 강제종료한다. 그렇지 않으면 페이지 테이블로 간다.
  3) 페이지 테이블에서 해당 페이지가 어느 프레임에 저장되어있는지 찾아 물리 메모리에 접근한다.
  4) 물리 메모리에 있는 프레임의 처음 위치에서 D만큼 떨어진 곳에 접근하여 데이터를 읽거나 쓴다. 
 
