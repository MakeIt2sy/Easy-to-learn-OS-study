# 물리 메모리 관리

<br />

## 메모리 관리자

<br />

메모리 관리는 메모리 관리자가 담당한다.

메모리 관리자는 <b>_메모리 관리 유닛(Memory Manage Unit)_</b> 이라는 하드웨어이다.

메모리 관리자의 작업은 _가져오기(fetch)_, _배치(batch)_, _재배치(replacement)_ 이다.

<hr>

- ### 가져오기 작업

  프로세스와 데이터를 메모리로 가져오는 작업

  사용자가 요청하면 프로세스와 데이터를 메모리로 가져온다.

  특정 상황에서는 데이터의 일부만 가져오기도 하며, 사용자의 요청이 없더라도 앞으로 필요할 것이라고 예상되는 데이터를 미리 가져오기도 한다.

  - 가져오기 정책

    프로세스가 필요로 하는 데이터를 언제 메모리에 올릴지 결정하는 정책

    필요하다고 예상되는 데이터를 <b>_미리 가져오는 방법(prefetch)_</b>도 있다.

<hr>

- ### 배치 작업

  가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업이다.

  메모리를 어떤 크기로 자를 것인지가 매우 중요하다.

  - 배치 정책

    메모리를 같은 크기로 자르는 것을 <b>_페이징(paging)_</b> 이라고 한다.

    프로세스의 크기에 맞게 자르는 것을 <b>_세그먼테이션(segmentation)_</b> 이라고 한다.

    배치 정책은 페이징과 세그먼테이션의 장단점을 파악하여 메모리를 효율적으로 관리할 수 있도록 하는 정책이다.

<hr>

- ### 재배치 작업

  새로운 프로세스를 메모리에 올리기 위해 꽉 차 있는 메모리에 오래된 프로세스를 제거하는 작업

  - 재배치 정책

    메모리가 꽉 찼을ㄷ 떄 메모리 내에 있는 어떤 프로세스를 내보낼지 결정하는 정책.

    앞으로 사용하지 않을 프로세스를 내보내면 시스템의 성능이 올라가지만

    자주 사용할 프로세스를 내보내면 성능이 떨어진다.

    앞으로 사용하지 않을 프로세스를 찾아서 내보내는 알고리즘을 <b>_교체 알고리즘(replacement algorithm)_</b> 이라고 한다.

<br />
<br />

## 메모리 주소

메모리에 접근할 때는 주소를 이용한다. 메모리 주소는 절대 주소와 상대 주소로 나뉜다.

<br />

### 32bit CPU와 64bit CPU의 차이

CPU의 비트는 한 번에 다룰 수 있는 데이터의 최대 크기를 의미한다.

32bit CPU는 한 번에 다룰 수 있는 데이터의 최대 크기가 32bit이고 64bit CPU는 64bit이다.

CPU 내부 부품도 모두 이 비트를 기준으로 제작된다.

CPU 내의 레지스터 크기는 전부 32bit이고, 산술 논리 연산장치도 32bit를 처리할 수 있도록 설계된다.

또한 데이터를 전송하는 각종 버스의 크기, 즉 대역폭도 32bit이다.

버스를 통해 한 번에 옮겨지는 데이터의 크기는 당연히 32bit 이다.

<br />

컴퓨터의 메모리 크기
| 구분 | 32bit CPU | 64bit CPU |
| --------- | -------------- | ---------------------- |
| 주소 범위 | 0~2^32 -1 번지 | 0~2^64 -1 번지 |
| 총크기 | 2^32B(약 4GB) | 2^64B(약 16.777.216TB) |

<br />

32bit CPU든 64bit CPU든 컴퓨터에는 메모리가 설치되며 각 메모리 주소 공간이 있다.

- 물리 주소 공간(physical address space)

  하드웨어 입장에서 바라본 주소 공간, 컴퓨터마다 크기가 다르다.

- 논리 주소 공간(logical address space)

  사용자 입장에서 바라본 주소 공간

<br />

![images_kwt0124_post_7faac7f0-2fe9-4468-a000-2535e15660b4_image](https://user-images.githubusercontent.com/103870198/214224146-f999b923-a551-42e2-a3e2-ce635f755775.png)

- 경계 레지스터

  운영체제 영역과 사용자 영역 경계 지점의 주소를 가진 레지스터이다.

  메모리 관리자는 사용자가 작업을 요청할 때마다 경계 레지스터의 값을 벗어나는지 검사하고,

  만약 경계 레지스터를 벗어나는 작업을 요청하는 프로세스가 있으면 그 프로세스를 종료한다.

<br />

### 절대 주소와 상대 주소

![image-15](https://user-images.githubusercontent.com/103870198/214227069-b0416041-4fe1-4f07-acf4-b9d9febdf686.png)

- 절대 주소(Absolute address)

  실제 물리 주소를 가리키는 주소, 메모리 관리자 입장에서 바라본 주소이다.

  즉, 메모리 레지스터가 사용하는 주소이며 컴퓨터에 꽂힌 램 메모리의 실제 주소를 의미한다.

- ​상대 주소(Relative address)

  사용자 영역이 시작되는 번지를 0번지로 변경하여 사용하는 주소, 사용자 프로세스 입장에서 바라본 주소이다.

  상대주소는 절대 주소에 관계없이 항상 0번지부터 시작한다.

​<br />

### 상대 주소를 절대 주소로 변환하는 과정

![image-18](https://user-images.githubusercontent.com/103870198/214227649-83d0d112-1fb8-4683-a72c-4311fdc2fa7a.png)

- 메모리 관리자는 사용자 프로세스가 상대 주소를 사용하여 메모리에 접근할 때마다 상대 주소 값에 재배치 레지스터 값을 더하여 절대 주소를 구함

- 재배치 레지스터는 주소 변환의 기본이 되는 주소 값을 가진 레지스터, 사용자 영역의 시작 주소가 저장됨

<br  />
<br  />

## 단일 프로그래밍 환경에서의 메모리 할당

<br />

### 메모리 오버레이

프로그램의 크기가 실제 메모리(물리 메모리)보다 클 때 전체 프로그램을 메모리에 가져오는 대신

적당한 크기로 잘라서 가져오는 기법을 <b>_메모리 오버레이(memory overlay)_</b> 라고 한다.

'overlay'는 겹겹이 쌓다, 중첩 시키다 라는 뜻으로 하나의 메모리에 여러 프로그램을 겹겹이 쌓아놓고 실행하는 것을 말한다.

메모리 오버레이는 프로그램을 몇 개의 모듈로 나누고 필요할 때마다 모듈을 메모리에 가져와 사용한다.

메모리 오버레이에서 어떤 모듈을 가져오거나 내보낼지는 CPU 레지스터 중 하나인 <b>_프로그램 카운터(PC)_</b> 가 결정한다.

> 프로그램 카운터(PC) : 앞으로 실행할 명령어의 위치를 가리키는 레지스터

메모리 오버레이의 의미

- 한정된 메모리에서 메모리보다 큰 프로그램 실행 가능(가상 메모리 시스템의 기본 개념)

- 프로그램 전체가 아닌 일부만 메모리에 올려도 실행 가능

<br />

### 스왑

![image-20](https://user-images.githubusercontent.com/103870198/214229754-c4504c12-3855-4715-b353-d1fa2d29fa19.png)

메모리가 모자라서 쫓겨난 프로세스는 저장장치의 특별한 공간에 모아두는데 이러한 영역을 <b>_스왑 영역(swap area)_</b> 라고 한다.

- 스왑 인 : 스왑 영역에서 메모리로 데이터를 가져오는 작업을 <b>스왑 인(swap in)</b> 이라고 한다.

- 스왑 아웃 : 메모리에서 스왑 영역으로 데이터를 내보내는 작업을 <b>_스왑 아웃(swap out)_</b> 이라고 한다.

스왑영역은 메모리 관리자가 관리한다.

원래 하드디스크 같은 저장장치는 저장장치 관리자가 관리하지만, 스왑 영역은 메모리에서 쫓겨났다가 다시 돌아가는 데이터가 머무는 곳이기 때문에

저장장치는 장소만 빌려주고 메모리 관리자가 관리하는 것이다.

> 최대 절전 모드 : 현재 작업 중인 상태 그대로 쉬게 하는 것이다. CPU와 메모리의 전력 공급을 끊기 때문에 메모리에 있는 내용이 모두 사라지는데, 이때 데이터를 옮기는 영역이 스왑 영역이다.

<br />
<br />

## 다중 프로그래밍 환경에서의 메모리 할당

<br />

### 메모리에 여러 개의 프로세스를 배치하는 방법

- 가변 분할 방식(variable-size partitioning)

  프로세스의 크기에 맞게 메모리가 분할 된다.

  한 프로세스가 연속된 공간에 배치되기 때문에 연속 메모리 할당(contiguous memory allocation) 이라고 한다.

  - 가변 분할 방식의 장점

    프로세스를 한 덩어리로 처리하며 하나의 프로세스를 연속된 공간에 배치

  - 가변 분할 방식의 단점

    비어 있는 공간을 하나로 합쳐야 하며, 이 과정에서 다른 프로세스의 자리도 옮겨야 하므로 메모리 관리가 복잡함.

- 고정 분할 방식(fixed-size partitioning)

  프로세스의 크기와 상관없이 메모리가 같은 크기로 나뉜다.

  큰 프로세스가 올라오면 여러 조각으로 나누어 배치된다.

  한 프로세스가 분산되어 배치되기 때문에 비연속 메모리 할당(noncontiguous memory allocation) 이라고 한다.

  - 고정 분할 방식의 장점

    메모리를 일정한 크기로 나누어 관리하므로 메모리 관리가 수월하다.

  - 고정 분할 방식의 단점

    쓸모없는 공간으로 인해 메모리 낭비가 발생할 수 있다.

현대 운영체제의 메모리 관리는 기본적으로 고정 분할 방식을 사용하며, 일부분은 가변 분할 방식을 혼합하고 있다.

<br />

### 내부 단편화, 외부 단편화

- 내부 단편화

![내부](https://user-images.githubusercontent.com/103870198/214233177-ed5898ae-70ea-4342-b5c2-2724508f25b1.jpeg)

메모리에 50mb 라는 빈 공간이 있고,

이 빈공간에 신규 프로세스(30mb)가 올라간다면

빈 공간은 50인데 30짜리 프로세스가 올라가서 20이라는 공간이 남는데, 남는 공간은 너무 작아 다른 작업들이 사용하지 못한다. 이러한 낭비되는 공간을 <b>내부 단편화</b> 라고 한다.

<br />

- 외부 단편화

![외부단편화](https://user-images.githubusercontent.com/103870198/214233318-db96e128-0eab-473d-a793-24175cb7c3a8.jpeg)

메모리에 남아있는 총 공간이 100mb(50mb + 50mb)이라 칠 때, 새로운 프로세스가 70mb일 경우 일어나는 경우이다.

작업보다 많은 공간이 남아 있더라도 실제로 그 작업을 받아 들이지 못하는 경우를 <b>외부 단편화</b> 라고 한다.

<br />

가변 분할 방식에서는 외부 단편화를 해결하기 위해 _메모리 배치 방식(memory placement strategy)_ 이나 _조각 모음(defragmentation)_ 을 사용한다.

<br />
<br />

### 메모리 배치 방식(memory placement strategy)

가변 분할 방식의 외부 단편화를 해결하기 위한 메모리 배치 방식으로는 최초 배치, 최적 배치, 최악 배치가 있다.

![images_im_lily_post_c0a1f217-2244-4ea2-bcbd-33225bc58d3d_image](https://user-images.githubusercontent.com/103870198/214234341-9a54a813-9970-4765-893a-5eb02620f8a0.png)

- 최초 배치(first fit)

  최초 배치는 단편화를 고려하지 않는 것으로, 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 프로세스를 배치 하는 방법

- 최적 배치(best fit)

  메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 프로세스를 배치하는 방법

- 최악 배치(worst fit)

  빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스를 배치하는 방법

<br />

### 조각 모음

![images_im_lily_post_5bcaa4b3-3d8f-4282-b26d-65e85d5635e9_image](https://user-images.githubusercontent.com/103870198/214234660-bfadf317-1bfc-4083-88d1-a93905a27ad5.png)

서로 떨어져 있는 여러 개의 빈 공간을 합치는 작업이다.

조각 모음을 하기 위해서는 프로세르르 중지시키고, 이동하고, 주소를 바꾸고, 다시 시작하는 작업을 해야 하기 때문에 많은 시간이 걸린다.

이처럼 가변 분할 방식은 외부 단편화로 인해 조각 모음 같은 부가적인 작업이 필요하므로 메모리 관리가 복잡하다.

<br />
<br />

### 고정 분할 방식의 메모리 관리

고정 분할 방식은 가변 분할 방식보다 공간을 효율적으로 관리하여 조각 모음 같은 부가적인 작업이 불필요하여 오늘날 고정 분할 방식을 기본으로 사용하고 있다.

![images_im_lily_post_f7764934-31c9-4d06-8e67-f9e1a1c71d1e_image](https://user-images.githubusercontent.com/103870198/214235226-83f5ff20-77d1-49aa-8134-c8b0c9f41b3a.png)

40kb인 프로세스 A는 프로세스 A1과 A2로 나뉘어 메모리에 할당된다.

30kb인 프로세스 C는 프로세스 C1과 C2로 나뉘는데 메모리에 남은 공간이 없으므로 프로세스 C2는 스왑 영역으로 옮겨진다.

<br />

### 내부 단편화

고정 분할 방식도 단점이 있다, 일정하게 나뉜 메모리의 크기보다 작은 프로세스가 배치될 경우 낭비되는 공간이 생기는데 이걸 내부 단편화라 한다.

같은 크기로 나뉜 공간의 내부에서 발생했기 때문에 이렇게 불린다.

동일하게 분할되는 공간의 크기를 조절하여 내부 단편화를 최소화 한다.

<br />

### 가변 분할 방식과 고정 분할 방식의 비교

| 구분        | 가변 분할 방식                   | 고정 분할 방식             |
| ----------- | -------------------------------- | -------------------------- |
| 메모리 단위 | 세그먼테이션                     | 페이징                     |
| 특징        | 연속 메모리 할당                 | 비연속 메모리 할당         |
| 장점        | 프로세슬를 한 덩어리로 관리 가능 | 메모리 관리가 편리         |
| 단점        | 빈 공간의 관리가 어려움          | 프로세스가 분할되어 처리됨 |
| 단편화      | 외부 단편화                      | 내부 단편화                |

<br />

### 버디 시스템

가변 분할 방식의 단점인 외부 단편화를 완화하는 방법으로 버디 시스템이 있다.

버디 시스템은 가변 분할 방식이지만 고정 분할 방식과 유사한 점이 있다.

메모리의 한 구역 내부에 조각이 생겨 내부 단편화가 발생한다.

1. 프로세스의 크기에 맞게 메모리를 1/2로 자르고 프로세스를 메모리에 배치한다.

2. 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어간다.

3. 프로세스가 종룓뢰면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다.

<br />

<br />

## 컴파일과 메모리 관리

## 참고

<hr>

https://m.blog.naver.com/rbdi3222/220623825770

https://velog.io/@im_lily/%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Chapter07-%EB%AC%BC%EB%A6%AC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC
