# CHAPTER 08 가상 메모리 기초

# 가상 메모리의 개요

물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술이다. 이를 통해 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경 쓰지 않고 프로그래밍할 수 있다.

가상 메모리 시스템에서 가변 분할 방식을 이용한 메모리 관리 기법은 세그먼테이션, 고정 분할 방식을 이용한 메모리 관리 기법은 페이징이라고 한다. 가상 메모리 시스템에서는 두 기법의 단점을 보완한 세그먼테이션-페이징 혼용 기법을 주로 사용한다.

# 페이징 기법

- **고정 분할 방식**을 이용한 가상 메모리 관리 기법
- 물리 주소 공간을 같은 크기로 나누어 사용한다.
- 가상 메모리의 분할된 각 영역을 페이지라고 부른다.
- 물리 메모리의 각 영역을 프레임이라고 부른다.
- 페이지와 프레임의 크기는 같고, 둘 다 번호를 매겨 관리한다.
- 페이지 테이블의 각 영역은 해당하는 프레임에 대한 매핑 정보를 가지고 있고, 만약 프레임에 올라와 있지 않은 내용이라면,  invalid로 표시되며, 이것은 해당 페이지가 스왑 영역에 있다는 의미이다.

## 페이징 기법의 주소 변환

### 프로세스가 30번지의 내용을 읽으려고 할 때

1. 가상 주소 30번지가 어느 페이지에 있는지 찾는다. 30번지는 페이지 3의 0번째 위치에 있다.
2. 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있다는 것을 알아낸다.
3. 최종적으로 물리 메모리 프레임 1의 0번째 위치에 접근한다. 이 주소가 가상 주소 30번지의 물리 주소이다.

### 프로세스가 가장 주소 18번지에 어떤 값을 저장하려고 할 때

1. 가상 주소 18번지가 어느 페이지에 있는지 찾는다. 18번지는 페이지 1의 8번째 위치에 있다.
2. 페이지 테이블의 페이지 1로 가서 해당 페이지가 프레임 3에 있다는 것을 알아낸다.
3. 프로세스가 저장하려는 값을 프레임 3의 8번 위치에 저장한다.

### 정형화된 주소 변환

$$
VA = <P,D> -> PA = <F,D>
$$

가상 주소 VA = <P(페이지), D(페이지의 처음 위치에서 해당 주소까지의 거리)> 를 물리 주소 PA = <F(프레임), D(프레임의 처음 위치에서 해당 주소까지의 거리)>로 변환한다. 각 페이지와 프레임의 크기는 같기 때문에 P는 F로 바꾸고 D는 그대로 사용한다.

## 페이지 테이블 관리

페이지 테이블은 메모리 관리자가 자주 사용하는 자료 구조이므로 필요시 빨리 접근할 수 있어야 한다. 따라서 페이지 테이블은 물리 메모리 영역 중 운영체제 영역의 일부분에 모아놓는다.

시스템에 여러 개의 프로세스가 존재하고, 각 프로세스마다 페이지 테이블이 하나씩 있기 때문에, 페이지 테이블 관리는 복잡하다. 가장 큰 문제는 페이지 테이블의 크기가 크다는 것이다. 최악의 경우 32bit CPU 시스템에서 페이지 테이블이 전체 4GB의 물리 메모리 중 1/4을 차지할 수도 있다. 따라서 페이지 테이블의 크기를 적정하게 유지하는 것이 페이지 테이블 관리의 핵심이다. 물리 메모리의 크기가 작을 때는 페이지 테이블의 일부도 스왑 영역으로 옮겨진다.

## 페이지 테이블 매핑 방식

### 직접 매핑

- 모든 페이지 테이블을 물리 메모리에 가지고 있는 가장 단순한 방식이다.
- 물리 메모리가 충분할 때 사용할 수 있다.
- 모든 페이지를 물리 메모리에 가지고 있기 때문에 주소 변환 속도가 빠르다.

### 연관 매핑

- 전체 페이지 테이블을 스왑 영역에 두고 페이지 테이블의 일부를 물리 메모리에 가져오는 방식이다.
- 메모리를 절약할 수 있어 물리 메모리의 여유 공간이 작을 때 사용하는 방식이다.
- 캐시 시스템과 비슷하게 작동한다. 원하는 페이지 번호가 변환 색인 버퍼에 있는 경우는 TLB 히트, 없는 경우는 TLB 미스라고 한다.
- TLB 히트의 경우 곧바로 물리 주소로 변환된다.
- TLB 미스의 경우 스왑 영역에 저장된 직접 매핑 테이블을 사용하여 프레임 번호로 변환한다. TLB 미스가 빈번하게 발생할 경우 시스템의 성능이 떨어진다.
- 변환 색인 버퍼는 페이지 테이블의 일부를 무작위로 가지고 있기 때문에 모든 변환 색인 버퍼를 검색한 후에야 원하는 페이지가 메모리에 없다는 것을 알 수 있다. 이 또한 TLB 미스가 발생할 경우 주소 변환이 느려지는 원인이다.

### 집합-연관 매핑(디렉터리 매핑)

- 연관 매핑에서 모든 변환 색인 버퍼를 검색한 후에야 TLB 미스가 있다는 사실을 알게 됨으로써 전체 시스템의 성능이 떨어지는 단점을 개선했다.
- 관련 있는 테이블을 덩어리로 모아놓은 형태이다.
- 전체 페이지 테이블은 연관 매핑과 마찬가지로 스왑 영역에 있으며, 일부 테이블을 묶음 단위로 메모리로 옮긴다. 따라서 해당 묶음이 현재 메모리에 있는지, 스왑 영역에 있는지를 표시하는 디렉터리 테이블을 새로 만든다. 디렉터리 테이블을 살펴보면 원하는 테이블 묶음이 어디에 있는지 알 수 있으므로 전체 테이블을 찾아보지 않아도 TLB 미스를 바로 알 수 있다.

### 역매핑

- 가상 주소의 페이지를 기준으로 프레임 번호를 매핑하지 않고, 물리 메모리의 프레임 번호를 기준으로 테이블을 작성한다. 즉, 물리 메모리가 어떤 프로세스의 어떤 페이지를 가지고 있는지를 테이블 형태로 구성한다.
- 테이블이 <프레임 번호, 프로세스 아이디, 페이지번호>로 구성된다.
- 페이지 테이블의 행 수는 실제 프레임의 수와 같다. 그러므로 프로세스의 수와 상관없이 항상 일정 크기의 페이지 테이블을 유지하여 **테이블의 크기가 매우 작다.**
- 주소 변환 시 메모리 관리자는 주소 변환을 해야 하는 프로세스의 아이디와 페이지 번호가 물리 메모리에 있는지 역매핑 테이블에서 검색한다. 만약 현재 테이블에 원하는 데이터가 없으면 스왑 영역에서 가져온다.
- 연관 매핑과 마찬가지로 페이지 테이블을 다 검사한 후에야 저장장치에 접근하기 때문에 검색 시간을 낭비하는 단점이 있다.

# 세그먼테이션 기법

- **가변 분할 방식**을 이용한 가상 메모리 관리 기법
- 물리 메모리를 프로세스의 크기에 따라 가변적으로 나누어 사용한다.
- 매핑 테이블을 사용한다.
- 매핑 테이블은 **세그먼트의 크기를 나타내는 limit**과 **물리 메모리상의 시작 주소를 나타내는 address**로 이루어진다.
- 메모리를 프로세스 단위로 관리하기 때문에 **페이지 테이블이 작고 단순**하다.
- **외부 단편화**가 발생한다.

## 세그먼테이션 기법의 주소 변환

$$
VA = <S, D>
$$

S: 세그먼트 번호, D: 세그먼트 시작 지점에서 해당 주소까지의 거리

### 주소 변환 과정 예(프로세스 A의 32번지에 접근하는 경우)

1. 먼저 가상 주소를 구한다. 프로세스 A는 세그먼트 0으로 분할되었으므로 S는 0이고 D는 32이다. 따라서 가상 주소는 VA = <0, 32>이다.
2. 세그먼테이션 테이블에서 세그먼트 0의 시작 주소를 알아낸 후 시작 주소 120에 거리 32를 더하여 물리 주소 152번지를 구한다. 이때 메모리 관리자는 거리가 세그먼트의 크기보다 큰지 점검한다. 만약 크다면(메모리를 벗어난다면) 메모리 오류를 출력하고 해당 프로세스를 강제 종료하며, 크지 않다면 물리 주소를 구한다.
3. 물리 주소 152번지에 접근하여 원하는 데이터를 읽거나 쓴다.

# 세그먼테이션-페이징 혼용 기법

## 특징

- 페이징 기법과 세그먼테이션 기법의 장점만 취한 가상 메모리 관리 기법
- 페이징 기법에서는 메모리 접근 권한을 고려하기 때문에 페이지 테이블의 모든 행에는 메모리 접근 권한과 관련된 권한 비트가 추가된다. 페이지 테이블에 대한 권한 비트가 추가되면 페이지 테이블의 크기가 커진다. 이 문제는 세그먼테이션 테이블을 이용하여 해결할 수 있다.
- 페이지로 분할된 가상 주소 공간에서 서로 관련 있는 영역을 하나의 세그먼트로 묶어 세그먼테이션 테이블로 관리하고, 각 세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리하는 방식이다. 각 세그먼테이션 테이블은 자신과 연결된 페이지 테이블의 시작 주소를 가진다.
- 현대 메모리 관리 기법이다.

## 세그먼테이션-페이징 혼용 기법의 주소 변환

가상 주소: VA = <S, P, D>

S: 세그먼트 번호, P: 페이지 번호, D: 페이지의 처음 위치에서 해당 주소까지의 거리

### 가상 주소를 물리 주소로 변환하는 과정

1. 사용자가 어떤 주소에 있는 데이터를 요청하면 해당 주소가 몇 번째 세그먼트의 몇 번째 페이지로부터 얼마나 떨어져 있는지 계산하여 가장 주소 VA = <S, P, D>를 구한다.
2. 세그먼테이션 테이블의 해당 세그먼트 번호로 가서 자신의 영역을 벗어나는 불법 접근이 아닌지, 권한이 없는 페이지에 접근하는 것은 아닌지 등을 확인한다. 만약 권한이 없는 페이지에 접근하거나 자신에게 주어진 메모리 영역을 벗어나면 세그먼테이션 오류(트랩)를 발생시켜 프로세스를 강제 종료하고, 그렇지 않으면 연결된 페이지 테이블로 간다.
3. 페이지 테이블에서 해당 페이지가 어느 프레임에 저장되었는지 찾는다. 만약 물리 메모리에 프레임이 있다면 메모리에 바로 접근하고, 없다면 스왑 영역에 가서 해당 페이지를 물리 메모리로 가져온다.
4. 물리 메모리에 있는 프레임의 처음 위치에서 D만큼 떨어진 곳에 접근하여 데이터를 읽거나 쓴다.