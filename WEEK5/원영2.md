# 가상 메모리

가상 메모리는 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술이다.

<br />

## 가상 메모리의 크기와 주소

- 주소

  가상 메모리에 모든 프로세스는 물리 메모리와 별개로 자신이 메모리의 어느 위치에 있는지 상관없이 0번부터 시작되는 연속된 메모리 공간을 가짐.

- 크기

  가상 메모리는 이론적으로는 무한대의 크기이나 실제로는 컴퓨터 시스템이 가진 물리 메모리의 최대 크기로 한정된다.

  메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 물리 메모리 + 스왑 영역을 합한 크기

- 동적 주소 변환(Dynamic Address Translation, DAT)

  가상 메모리 시스템에서 프로세스가 참조하는 주소를 실제 주기억 장치의 주소로 바꿔야 하는데,

  이 과정이 프로세스 수행 중에 일어나는 것

<br />

## 가상 메모리의 분할 방식

가상 메모리 시스템에서 가변 분할 방식을 이용하면 세그먼테이션,

고정 분할 방식을 이용하면 페이징 이라고 한다.

세그먼테이션은 외부 단편화 문제 때문에 잘 사용 안하고

페이징 기법은 페이징 관리의 어려움이 있어서, 둘을 혼합한 <b>_세그먼테이션-페이징 혼용 기법_</b> 을 주로 사용한다.

| 구분             | 가상 메모리                   | 물리 메모리          |
| ---------------- | ----------------------------- | -------------------- |
| 최대 메모리 크기 | CPU의 비트 값에 의존          | CPU의 비트 값에 의존 |
| 메모리 분할 방식 | 세그먼테이션                  | 가변 분할 방식       |
|                  | 페이징                        | 고정분할방식         |
|                  | 세그먼테이션-페이징 혼용 기법 |                      |
| 주소 지정 방식   | 가상 주소                     | 절대 주소, 상대 주소 |

<br />

## 매핑 테이블

가상 메모리 시스템에서 가상 주소와 실제 물리 메모리 주소를 1:1 매핑 해놓은 테이블

매핑 테이블은 물리 메모리가 세그먼테이션, 페이징 어느 기법으로 분할되던 똑같은 방식으로 적용된다.

페이징 기법에서 사용하는 매핑 테이블은 _페이지 매핑 테이블_ 또는 _페이지 테이블_ 이라고 하며,

세그먼테이션 기법에서 사용하는 매핑 테이블은 _세그먼테이션 매핑 테이블_ 또는 _세그먼테이션 테이블_ 이라고 한다.

![image-29](https://user-images.githubusercontent.com/103870198/214481876-309fc5a4-022d-4e2d-b65c-f0a20553f920.png)

<br />
<br />

## 페이징 기법

고정 분할 방식을 이용한 가상 메모리 관리 기법으로 물리 주소 공간을 같은 크기로 나누어 사용한다.

- 페이지

  가상 주소의 분할된 각 영역을 페이지라고 부른다.

  번호를 메겨 관리한다.

- 프레임

  물리 메모리의 각 영역은 프레임이라고 부른다.

  번호를 메겨 관리한다.

페이지와 프레임의 크기는 같다.

어떤 페이지가(가상 주소) 어떤 프레임(물리 주소) 에 담겨 있는지는 매핑 테이블에 있다.

페이지 테이블은 하나의 열(column) 로 구성된다.

페이지가 물리 메모리에 없을 경우 페이지 테이블에 invalid라고 표시되며, invalid는 해당 페이지가 스왑 영역에 있다는 것이다.

```json
  // 페이징 기법의 주소 변환 과정
  VA = <P, D>

  VA = Virtual Address // 가상 주소
  P = Page // 페이지
  D = Distance // 페이지의 처음 위치에서 해당 주소까지의 거리, D를 오프셋 이라고 하기도 함.

  VA = <P, D> -> PA = <F, D> // F는 Frame
```

<br />

## 세그먼테이션 기법

프로세스의 크기에 따라 메모리를 분할하기 때문에 매핑 테이블에 크기정보를 포함한다.

세그먼트 테이블에는 세그먼트의 크기를 나타내는 limit과 물리 메모리상의 시작 주소를 나타내는 address가 있다.

![image](https://user-images.githubusercontent.com/103870198/214492381-e7390835-f164-42b9-b559-d86373fb5cea.png)

- 장점 : 메모리를 프로세스 단위로 관리하기 때문에 페이지 테이블이 작고 단순하다.
- 단점 : 물리 메모리의 외부 파편화로 인해 관리가 복잡하다.

```json
  // 세그먼테이션 기법의 주소 변환 과정

  VA = <S, D>

  VA = Virtual Address // 가상 주소
  S = Segment number // 세그먼트 번호
  D = Distance // 세그먼트 시작 지점에서 해당 주소까지의 거리

  // 시작 주소 + D

```

limit에 크기보다 더 큰 주소에 접근하려 하면 오류를 발생시키는데 이걸 _트랩(trap)_ 이라 한다.

<br />
<br />

## 세그먼테이션-페이징 혼용 기법

페이징 기법은 메모리 관리가 수월하나 페이지 테이블의 크기가 크다는 단점이 있음.

세그먼테이션 기법은 테이블 크기를 작게 유지할 수 있는 반면 외부 단편화로 인해 메모리 관리가 어려움.

이 둘의 장점을 취한 기법이 세그먼테이션-페이징 혼용 기법이다.

<br />

### 메모리 접근 권한

- 메모리 접근 권한이란 메모리 특정 주소에 저장된 데이터를 사용할 수 있는 권한을 의미.

- 권한에는 _<b>읽기, 쓰기, 실행, 추가</b>_ 4가지가 존재한다.

- 가상주소에서 물리 주소로 변환이 일어날 때마다 접근 권한 검사가 시행된다.

- 권한에 맞지 않는 실행을 하려고 하면 _트랩_ 발생

<br />

### 페이징 기법의 메모리 권한 설정

- 페이지마다 접근 권한이 다르기 때문에 페이지 테이블의 모든 행에 _권한 비트(right bit)_ 가 추가된다.

- 메모리 관리자는 페이지 테이블의 권한 비트를 이용하여 유용한 접근인지 아닌지 확인한다.

### 세그먼테이션 테이블의 혼합

- 페이지 테이블에 권한 비트를 추가하면 크기가 커지고 인접한 페이지의 메모리 접근 권한이 같은데도 페이지마다 권한 설정을 해주어야 해서 낭비가 심함.

- 권한 별로 세그먼테이션 테이블로 묶어서 관리한다.

![images_thalals_post_ef602c0f-b138-4604-9355-9daf2a66dc6d_image](https://user-images.githubusercontent.com/103870198/214497010-100f6ebb-537b-4be6-98a3-f865d341ee22.png)
