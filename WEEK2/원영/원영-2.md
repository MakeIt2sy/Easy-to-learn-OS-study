# 프로세스와 스레드

## 프로세스의 개념

- 프로그램 : 하드디스크와 같은 저장장치에 저장되어 있는 정적인 상태
- 프로세스 : 프로그램 실행을 위해 메모리에 올라온 동적인 상태

프로세스는 컴퓨터 시스템의 작업 단위로 태스크(task)라고도 부른다.

<br />

## 프로세스 제어 블록(PCB)

프로세스 제어 블록에는 프로세스를 처리하는데 필요한 다양한 정보가 들어 있다.
프로그램이 프로세스가 되려면 메모리에 올라오는 것과 동시에 프로세스 제어블록이 생성되어야 한다.

- 프로세스 구분자 : 각 프로세스를 구분하는 ID 이다. (PID)
- 메모리 관련 정보 : 실행하려는 프로세스의 메모리 위치 정보가 담겨 있다, 또한 메모리 보호를 위해 경계,한계 레지스터도 포함되어 있다.
- 각종 중간값 : 시분할 시스템에서는 여러 프로세스를 번갈아가며 실행하기 때문에 다음에 작업해야 할 코드의 위치가 담긴 프로그램 카운터와 현재 작업의 중간값을 보관 중인 다른 레지스터도 같이 저장된다.

<br />

## 프로세스의 네 가지 상태

- 생성 상태(create status) : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태, 프로세스 제어 블록이 생성된다.
- 준비 상태(ready status) : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
- 실행 상태(running status) : 프로세스가 CPU를 얻어 실행중인 상태, 시간을 다 쓰고도 작업이 끝나지 않으면 다시 준비 상태로 돌아감
- 완료 상태(terminate status) : 실행 상태의 프로세스가 작업을 완료한 상태, PCB가 제거된 상태

오늘날에는 운영체제의 효율성을 고려하여 대기 상태 라는 한가지 상태를 더 만들었다.

| 상태      | 설명                                                                                                                   | 작업                                                                         |
| --------- | ---------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| 생성 상태 | 프로그램을 메모리에 가져와 실행 준비가 완료된 상태                                                                     | 메모리 할당, 프로세서 제어 블록 생성                                         |
| 준비 상태 | 실행을 기다리는 모든 프로세스가 자기 차례를 기다리는 상태, 실행될 프로세스를 CPU 스케줄러가 선택한다.                  | dispatch(PID): 준비 -> 실행                                                  |
| 실행 상태 | 선택된 프로세스가 타임 슬라이스를 얻어 CPU를 사용하는 상태이다. 프로세스 사이에 문맥 교환이 일어난다.                  | timeout(PID): 실행 -> 준비, exit(PID): 실행-> 완료, block(PID): 실행 -> 대기 |
| 대기 상태 | 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될때까지 기다리는 상태, 입출력이 완료되면 준비 상태로 간다. | wareup(PID): 대기 -> 준비                                                    |
| 완료 상태 | 프로세스가 종료된 상태, 사용하던 모든 데이터가 정리된다. 정상 종료인 exit와 비정상 종료인 abort를 포함한다.            | 메모리 삭제, 프로세스 제어블록 삭제                                          |

<br />

## 휴식상태와 보류 상태

- 휴식 상태(pause status): 프로세스가 일시적으로 작업을 쉬는 상태, 사용하던 데이터가 메모리에 그대로 남아있고 PCB도 유지되므로 멈춘 지점에서부터 다시 재시작(resume) 할 수 있다.
- 보류 상태(suspend status): 프로세스가 메모리에서 잠시 쫓겨난 상태, 보류 상태의 프로세스는 메모리 밖으로 쫓겨나 스왑 영역에 보관된다.

> ⚠️ fg는 foreground job의 약자, bg는 background job의 약자이다. stop 상태의 작업을 전면 또는 후면에서 재시작하라는 명령어이며 후면에서 작동하는 명령어는 끝에 & 가 붙는다.

<br />
<br />

# 프로세스 제어 블록과 문맥 교환

<br />

## 프로세스 제어 블록의 구성

| 포인터 |                    | 프로세스 상태 |
| -----: | ------------------ | :------------ |
|        | 프로세스 구분자    |               |
|        | 프로그램 카운터    |               |
|        | 프로세스 우선순위  |               |
|        | 각종 레지스터 정보 |               |
|        | 메모리 관리 정보   |               |
|        | 할당된 자원 정보   |               |
|        | 계정 정보          |               |
|        | PPID와 CPID        |               |

<br />

## 문맥 교환(context switching)

컨텍스트 스위칭이란 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다.

이때 두 프로세스 제어 블록의 내용이 변경된다.

실행중이던 프로세스의 PCB에는 지금까지의 작업 내용을 저장하고, 반대로 새로 실행되는 프로세스의 PCB의 내용으로 CPU가 세팅된다.

컨텍스트 스위칭은 타임아웃, 인터럽트가 발생할ㄷ 때 일어난다.

<br />

## 프로세스의 구조

프로세스는 코드 영역, 데이터 영역, 스택 영역으로 이루어진다.

- 코드 영역(code area) : 프로그램의 본문이 기술된 텍스트 영역, 읽기 전용으로 처리된다.
- 데이터 영역(data area)
  - 일반 데이터 영역 : 코드가 실행되면서 사용되는 변수나 파일등의 각종 데이터를 모아 놓은 곳, 기본적으로 읽기/쓰기가 가능하다.
  - 힙(heap) 영역 :
- 스택 영역(stack area) : 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳, 함수를 호출하면 함수를 수행하고 원래 프로그램으로 돌아올 위치를 이 영역에 저장한다.

<br />

## 프로세스의 생성과 복사

기본적으로 프로세스는 프로그램을 실행할 때 새로 생성된다. 다만 같은 프로그램을 여러번 실행 하는 경우 복사를 한다.

<br />

## fork()

fork() 시스템 호출은 실행중인 프로세스로부터 새로운 프로세스를 복사하는 함수이다.
(워드나 엑셀 여러개 띄우는 것 처럼 이해하면 될 듯)

fork() 시스템 호출로 복사하면 기존의 프로세스와 새로 복사된 프로세스는 부모-자식 관계가 된다.

### fork() 시스템 호출 후 프로세스의 변화

- PID가 바뀐다.
- 메모리 정보가 바뀐다.
- 부모 프로세스의 CPID와 자식 프로세스의 PPID가 바뀐다.

<br />

### fork() 시스템 호출의 장점

- 프로세스의 생성 속도가 빠르다.(기존걸 복사하기 떄문)
- 부모 프로세서가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속할 수 있다.
- 시스템 관리를 효율적으로 할 수 있다. 서로 부모/자식 PID로 연결되어 있기때문에 자식 프로세스를 종료하면 부모 프로세스가 정리할 수 있다.

<br />

## exec() 시스템 호출의 개념

fork는 프로세스 하나를 복사하는것이지만 exec은 기존의 프로세스 구조를 그대로 둔 채 내용만 바꾸어 실행하는 것이다.
프로세스 구분자(PID, PPID, CPID) 만 남기고 나머지 내용을 새로운 것으로 바꾼다.

<br />

## 프로세스의 계층 구조

- 여러 작업의 동시 처리
  - login 프로세스를 fork로 복사해서 여러 사용자를 동시에 처리
  - login 프로세스를 exec()을 사용해서 shell 프로세스로 재활용
- 자원 회수가 용이함.
  - 자식 프로세스가 작업을 마치면 부모 프로세스가 회수하면 된다.

<br />

## 고아 프로세스(orphan process) 또는 좀비 프로세스(zombie process)

- 부모 프로세스가 먼저 종료되거나 자식 프로세스가 비정상적으로 종료되어서 종료되었는데도 사용하던 자원이 그대로 남아있는 경우

<hr>

q1. 프로세스란 무엇일까요?

q2. PCB에 대해 설명해주세요

q3. 컨텍스트 스위칭에 대해 설명해주세요

q4. fork() 와 exec() 시스템 호출에 대해 설명해주세요

q5. 좀비 프로세스를 죽이는 방법은?
