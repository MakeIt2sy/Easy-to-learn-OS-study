# 프로세스와 스레드

## 1. 프로세스의 개요  
<br/>

### [프로세스의 개념]
<br/>

 프로그램은 저장장치에 저장되어 있는 정적인 상태이고, 프로세스는 실행을 위해 메모리에 올라와 있는 동적인 상태이다.  
 프로세스는 컴퓨터 시스템의 작업 단위로 태스크라고도 부른다. 

<br/>

### [프로세스의 상태]
<br/>

시분할 시스템에서의 프로세스 상태는 일괄 작업 시스템보다 복잡하다. 실행중인 프로세스가 중간에 다른 프로세스에 CPU를 넘겨주는 일이 빈번하기 때문이다. 
기본적으로 프로세스의 상태는 생성상태, 준비상태, 실행상태, 대기상태, 완료상태 이렇게 5가지로 나타낼 수 있다. 

 - 생성 상태 
   - 프로그램이 메모리에 올라오고 운영체제로부터는 프로세스 제어블록(PCB)를 할당받은 상태이다.
 - 준비 상태
   - 프로세스가 자기 순서를 기다리는 상태이다. 프로세스 제어 블록은 ready queue에서 기다리며 CPU스케줄러에 의해 관리된다.  
     CPU스케줄러가 특정 프로세스 제어 블록을 선택하여 dispatch(PID) 명령을 실행하면 준비 상태에서 실행 상태로 바뀐다.
 - 실행 상태 
   - 프로세스가 CPU를 할당받아 실행되는 상태이다. 실행 상태의 프로세스는 자신에게 주어진 타임 슬라이스 동안 작업할 수 있다.  
     시간을 다 사용하면 timeout(PID)가 실행되어 프로세스 제어블록이 준비 상태로 돌아간다. 만약 실행 상태 동안 모든 작업이 완료되었다면 exit(PID)가 실행되어 프로세스가 종료된다.
     실행 상태에 있는 프로세스가 입출력을 요청한 경우, CPU는 입출력 관리자에게 입출력을 요청하고 block(PID)를 실행한다. 이 경우 해당 프로세스는 대기 상태 상태로 옮겨지고 새로운 프로세스가 실행 상태로 간다.
 - 대기 상태
   - 실행 상태에 있던 프로세스가 입출력을 요청했을 때 입출력이 완료될 때까지 기다리는 상태이다. 대기 상태의 프로세스는 입출력장치별로 마련된 큐에서 기다리다가 입출력이 완료된 후 인터럽트가 발생하면 wakeup(PID) 명령으로 프로세스를 깨우고 준비 상태로 이동시킨다. 
 - 완료 상태
   - 프로세스가 종료되는 상태이다. 이때 코드와 데이터를 메모리에서 삭제하고 프로세스 제어 블록을 폐기한다. 정상 종료는 exit()로 처리하고, 비정상 종료는 디버깅을 위해 강제 종료(abort) 직전의 메모리 상태를 저장장치로 옮기는데 이를 코어 덤프라고 한다.  

<br/>

대부분의 프로세스는 5가지의 활성 상태로 운영이 되는데 이외에 또 다른 상태가 있다. 

- 휴식 상태
  - 프로세스가 작업을 일시적으로 쉬고 있는 상태이다. 메인 메모리에 데이터도 그대로 있고, 프로세스 제어 블록도 유지가 되기 때문에 멈춘 지점에서부터 재시작할 수 있다.

- 보류 상태
  - 프로세스가 메모리에서 잠시 쫓겨난 상태이다. 악의적인 프로세스로 판단되거나 메모리가 꽉차 있어서 일부 프로세스를 밖으로 내보낼 때, 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때 등의 상황에서 보류 상태가 된다. 이 프로세스들은 swap 영역에 보관된다. 

<br/>

## 2. 프로세스 제어 블록과 문맥 교환
<br/>

### [프로세스 제어 블록]
<br/>

프로세스 제어블록은 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조이다. 모든 프로세스는 고유의 프로세스 제어블록을 가지며, 생성시에 만들어져서 완료시에 폐기된다.

 - 프로세스 제어 블록의 구성
   - 포인터 : 프로세스 제어 블록의 첫 번째 블록에 저장된다. 프로세스가 준비상태나 대기 상태일 경우에 큐로 운영이 되는데, 프로세스 제어 블록을 연결 시 큐로 구현하기 위해 포인터를 사용한다.
   - 프로세스 상태 : 현재 프로세스가 어떤 상태에 있는지를 나타내고 PCB의 두 번째 블록에 저장된다.
   - 프로세스 구분자 : 운영체제 내의 여러 프로세스를 구별하기 위한 구분자를 저장한다.
   - 프로그램 카운터 : 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값을 저장한다.
   - 프로그램 우선순위 : CPU스케줄러가 준비 상태에 있는 프로세스 중에 실행 상태로 옮길 프로세스를 선택할 때 기준이 되는 것으로 높은 우선순위의 프로세스가 낮은 순위의 프로세스보다 먼저,더 자주 실행된다.
   - 각종 레지스터 정보 : 프로세스가 실행 중에 사용했던 레지스터 정보들이 저장된다. 
   - 메모리 관리 정보 : 프로세스가 메모리의 어디에 있는지 나타내는 위치 정보, 메모리 보호를 위해 사용하는 경계 레지스터 값과 한계 레지스터 값 등이 저장된다.
   - 할당된 자원 정보 : 입출력 자원이나 오픈 파일 등에 대한 정보가 저장된다. 
   - 계정 정보 : 계정 번호, CPU 할당 시간, 사용시간 등이 저장된다. 
   - 부모 프로세스 구분자(PPID)와 자식 프로세스 구분자(CPID) : PPID와 CPID가 저장된다.

<br/>

### [문맥 교환]
<br/>

CPU를 사용하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 문맥 교환이라고 한다. 실행 상태에서 나가는 프로세스 제어 블록에는 지금까지의 작업 내용을 저장하고, 실행 상태로 들어오는 프로세스 제어블록의 내용으로 CPU가 다시 세팅된다. 

<br/>

## 3. 프로세스의 연산
<br/>

### [프로세스의 구조]
<br/>

 프로세스는 코드 영역, 데이터 영역, 스택 영역으로 구성된다. 

 - 코드 영역 : 프로그램 본문이 기술된 곳으로 텍스트 영역이라고도 한다. 읽기 전용.
 - 데이터 영역 : 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 영역이다. 읽기/쓰기 가능.
 - 스택 영역: 운영체제가 프로세스를 실행하는 데에 부수적으로 필요한 데이터를 모아놓은 영역이다. 예를 들어 함수를 호출하면 함수를 수행하고 다시 돌아올 위치를 이 영역에 저장한다. 사용자에게는 보이지 않는 영역.
<br/>

### [프로세스 생성과 복사]
<br/>

 프로세스를 새로 생성하는 방법뿐만 아니라 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 방법도 있다. 

 1. fork()
   - 실행 중인 프로세스를 복사하여 새로운 프로세스를 만드는 시스템 호출을 말한다. 
   - 이때 실행하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스가 된다. 
   - fork() 시스템 호출을 하면 프로세스 제어 블록을 포함하여 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어진다. 단, PCB에서 프로세스 구분자, PPID, CPID, 메모리 관련 정보가 바뀐다. 
   - 장점 
     - 프로세스 생성 속도가 빠르다. 하드 디스크에서 프로그램을 새로 가져오지 않고 기존 메모리에서 복사하기 땜누에 자식 프로세스의 생성 속도가 빠르다. 
     - 추가 작업 없이 자원을 상속할 수 있다. 
     - 시스템 관리를 효율적으로 할 수 있다. 부모-자식 프로세스가 연결되어 있기 때문에 자식 프로세스가 종료되면 부모 프로세스가 자원을 정리해줘서 시스템에 효율적으로 관리될 수 있다. 

 2. exec()
   - 프로세스를 그대로 두고 내용만 바꾸는 시스템 호출을 말한다. 현재의 프로세스와 완전 다른 프로세스로 전환된다.
   - 새로운 프로세스를 만들 때 제어 블록을 만드록 메모리 자리를 확보하는 과정, 프로세스 종료 후 메모리 청소하는 과정 없이 이미 만들어진 프로세스의 구조를 재활용할 수 있다.
   - 코드 영역을 새로운 코드로 바꾸고 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋된다. 그리고 프로세스 제어 블록 내용 중 프로그램 카운터 레지스터 값을 비롯한 각종 레지스터와 사용한 파일 정보가 리셋된다. 
   
<br/>

### [프로세스 계층 구조]
<br/>

 프로세스는 실행 중에 프로세스 생성 시스템 호출을 이용해 새로운 프로세스를 생성할 수 있다. 이 때 프로세스 생성 순서를 저장하고 부모-자식 관계를 유지하여 계층적으로 생성한다. 부모 프로세스는 자신의 자원을 자식 프로세스에 상속하고 자식 프로세스가 종료되면 그 자원을 회수한다. 

 - 장점: 여러 작업을 동시에 처리할 수 있고 자원 회수가 용이하다. 
 ** 미아 프로세스 : 프로세스가 종료된 후에도 비정상적으로 남아있는 프로세스를 말한다. 미아 프로세스가 많아지면 자원이 낭비되기 때문에 운영체제는 반환되지 못한 자원을 주기적으로 회수해야한다. 

<br/>

## 4. 스레드
<br/>

### [스레드의 개념]
<br/>

 스레드는 프로세스 안에서 실행되는 흐름 단위를 말한다. 
 스레드는 프로세스 내에서 스택만 따로 할당받고 코드, 데이터, 힙영역은 공유한다.

 - 멀티 스레드 : 프로세스 내 작업을 여러 개의 스레드로 분할하여 작업의 부담을 줄이는 프로세스 운영 기법이다.
 - 멀티태스킹 : 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법이다.
 - 멀티프로세싱 : 여러 개의 CPU를 사용하여 여러 개의 스레드를 동시에 처리하는 기법을 말한다. 
 - CPU 멀티스레드 : 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법이다.
<br/>

### [멀티스레드의 구조와 예]
<br/>

 프로세스는 크게 정적인 영역과 동적인 영역으로 구분된다. 정적인 영역은 프로세스가 실행되는 동안 바뀌지 않고, 동적인 영역은 작업을 하면서 계속 바뀌는 영역이다. fork() 시스템 호출로 여러 개의 프로세스를 만들면 필요 없는 정적 영역이 많아지지만 멀티 스레드를 사용하면 코드, 파일 등의 자원을 공유할 수 있어 자원의 낭비를 막고 효율성을 향상시킨다. 
<br/>

### [멀티스레드의 장단점]
<br/>

 - 장점
   - 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빠른 응답이 가능하다.
   - 프로세스가 가진 자원을 모든 스레드가 공유할 수 있다.
   - 불필요한 자원의 중복을 막아 시스템 효율이 향상된다.
 - 단점 
   - 프로세스끼리는 독립적이기 때문에 한 프로세스의 문제가 다른 프로세스로 전달되지 않지만 스레드끼리는 자원을 공유하기 때문에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미친다. 

<br/>

### [멀티스레드 모델]
<br/>   
 
 - 사용자 레벨 스레드 : 운영체제가 멀티스레드를 지원하지 않을 때 사용하는 방법으로 초기의 스레드 시스템에서 이용되었다. 이 스레드는 사용자 레벨에서 스레드를 구현하기 때문에 관련 라이브러리를 사용하여 구현한다. 커널 입장에서는 하나의 프로세스이지만 커널이 하는 일을 라이브러리가 대신 처리하여 여러 개의 스레드를 작동한다. 
  라이브러리가 직접 스케줄링하고 필요한 정보를 처리하기 때문에 문맥 교환이 필요 없어 작업 속도가 빠르다. 그러나 여러 개의 스레드가 하나의 커널 스레드와 연결되기 때문에 커널 스레드가 입출력을 위해 대기 상태에 들어가면 모든 사용자 스레드가 같이 대기하게 된다. 또 여러 개의 cpu를 동시에 사용할수 없다. 

 - 커널 레벨 스레드 : 커널이 멀티 스레드를 지원하는 방법이다. 하나의 사용자 스레드가 하나의 커널 스레드와 연결된다. 장단점은 사용자 스레드와 정반대이다.

 - 멀티 레벨 스레드 : 사용자 레벨 스레드와 커널 레벨 스레드를 혼합한 방식이다. 

 ---
 질문 
 1. 멀티 프로세스와 멀티 스레드는 각각 어떤 상황에서 사용하면 좋을까요?
 
