# CHAPTER 03 프로세스와 스레드

# 프로세스의 개요

## 프로세스

프로그램은 저장장치에 저장되어 있는 정적인 상태이다. 반면에 프로세스는 **실행을 위해 메모리에 올라온 동적인 상태**이다. 누군가가 작성한 프로그램이, 실행되면 프로세스가 된다.

## 프로그램 실행 과정

1. 디스크에 있는 프로그램이 RAM에 적재되며, PCB가 생성된다.
2. RAM에 적재된 프로그램이 CPU 할당을 받는다.
3. 해당 프로그램은 비로소 프로세스로 전환되어 실행된다.

## 프로세스의 구조

| Stack | 지역변수, 매개변수가 저장되는 임시 메모리 영역 |
| --- | --- |
| Heap | 동적 메모리 할당/해제가 가능한 영역 |
| Data | 전역변수, static 변수가 저장되는 영역 |
| Code | 기계어로 번역된 코드가 저장되는 영역 |

## 프로세스의 상태

![프로세스_상태.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/0935a729-8764-494a-b252-00bfd3e2a03b/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230107%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230107T145029Z&X-Amz-Expires=86400&X-Amz-Signature=3126f58580caf5cbf845850f2560364f912909a6bc3b566484be14e54837b63b&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EC%2583%2581%25ED%2583%259C.png%22&x-id=GetObject)

### 생성 상태(Create Status)

프로그램이 메모리에 올라오고 OS로부터 PCB를 할당받은 상태이다. 즉, 실행 준비가 완료된 상태이다.

**작업**

메모리 할당, PCB 생성

### 준비 상태(Ready Status)

실행 대기 중인 모든 프로세스가 자신의 차례를 기다리는 상태이다.  PCB는 준비 큐에서 기다리며 CPU 스케줄러에 의해 관리된다.

**작업**

CPU 스케줄러가 dispatch(PID) 명령으로 PCB 선택

### 실행 상태(Running Status)

프로세스가 CPU를 할당받아 실행되는 상태이다. 실행 상태에 있는 프로세스는 자신에게 주어진 시간동안만 작업할 수 있다.

**작업**

- 자신에게 주어진 시간을 다 사용하면 **timeout(PID)**에 의해 PCB가 실행 상태→ 준비 상태가 된다.
- 실행 상태 동안 작업이 완료되면 **exit(PID)**가 실행되어 프로세스가 정상 종료된다.
- 실행 상태 동안 프로세스가 입출력을 요청하면 CPU는 입출력 관리자에게 입출력을 요청하고 **block(PID)**를 실행한다. block(PID)가 실행되면 입출력이 완료될 때까지 작업을 진행할 수 없기 때문에 해당 프로세스를 대기 상태로 옮긴다. 그 후 CPU 스케줄러는 dispatch(PID)를 통해 새로운 프로세스를 실행 상태로 가져온다.

### 대기 상태(Blocking Status)

실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태이다. 입출력이 완료되면 인터럽트가 발생하고,  **wakeup(PID)**를 통해 대기 상태에 있는 여러 프로세스 중 해당 인터럽트로 깨어날 프로세스를 찾고, 해당 프로세스의 PCB가 준비 상태로 이동하게 된다.

**작업**

대기 상태→준비 상태를 위한 wakeup(PID)

### 완료 상태(Terminate Status)

프로세스가 종료되는 상태이다. 코드와 사용했던 데이터를 메모리에서 삭제하고 PCB를 폐기한다. 정상적인 종료 시 exit(), 비정상적 종료 시 디버깅을 위해 **코어 덤프**(강제 종료 직전의 메모리 상태)를 저장장치로 옮긴다.

**작업**

메모리 삭제, PCB 삭제

### 휴식 상태(Pause Status)

프로세스가 작업을 일시적으로 쉬고 있는 상태이다.  사용하던 데이터가 메모리에 그대로 있고, PCB도 유지되기 때문에 프로세스는 멈춘 지점에서부터 재시작할 수 있다.

### 보류 상태(Suspend Status)

프로세스가 메모리에서 잠시 쫓겨난 상태이다. ‘일시 정지 상태’라고도 불린다. 보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑 영역에 보관된다.

보류 상태는 대기 상태에서 옮겨진 보류 대기 상태와 준비 상태에서 옮겨진 보류 준비 상태로 구분되며, 각 상태에서 재시작하면 원래의 활성 상태로 들어간다. 만약 보류 대기 상태에서 입출력이 완료되면 활성 상태가 아닌 보류 준비 상태로 옮겨 간다.

**보류 상태가 되는 경우**

- 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
- 프로그램에 오류가 있어서 실행을 미루어야 할 때
- 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
- 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
- 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때

<aside>
💡 **보류 상태 VS 휴식 상태**
보류 상태: 프로세스가 스왑 영역에 있는 상태
휴식 상태: 프로세스가 메모리에 있으나 멈춘 상태

</aside>

## 시분할 시스템에서의 문맥 교환

### 시분할 시스템

여러 개의 프로세스가 1개의 CPU 코어에서 실행될 때, 각 프로세스마다 매우 짧은 시간을 할당 받아 프로세스들끼리 번갈아 가며 프로세스를 실행하는 것

### 컨텍스트

시분할 시스템에서 각 프로세스가 가지는 총체적인 정보이다. 이전에 어디까지 명령을 수행했고, 레지스터에는 어떤 값이 저장되어 있는지에 대한 정보가 있다.

### PCB(Process Control Block)

컨텍스트의 정보를 저장하는 곳으로, 운영체제 커널의 자료구조로, 프로세스를 표현할 때 사용한다. 즉, PCB는 운영체제가 프로세스를 표현한 것이다. PCB에는 프로세스의 중요한 정보가 포함되어 있기 때문에 일반 사용자가 접근하지 못하는 보호된 메모리 영역에 저장된다.

### PCB의 구성

| 포인터 | PCB를 연결하여 준비 상태나 대기 상태의 큐를 구현할 때 사용한다. |
| --- | --- |
| 프로세스 상태 | 프로세스가 현재 어떤 상태에 있는지 나타낸다. |
| 프로세스 식별자(Proces ID) | OS 내에 있는 여러 프로세스를 식별한다. |
| 프로그램 카운터(PC) | 다음에 실행할 명령어의 주소를 가리킨다. |
| 프로세스 우선순위 | 프로세스의 우선순위를 나타낸다. 커널 프로세스의 우선순위가 가장 높고, 사용자 프로세스끼리의 우선순위도 각각 다르다.
대기 상태의 큐도 각 우선순위별로 따로 운영된다. CPU 스케줄러가 준비 상태에 있는 프로세스 중 실행 상태로 옮겨야 할 프로세스를 선택할 때는 프로세스 우선순위를 기준으로 한다. |
| 각종 레지스터 정보 | 사용하던 레지스터들의 값을 보관한다. |
| 메모리 관리 정보 | 메모리 위치 정보, 경계 레지스터 값, 한계 레지스터 값, 세그먼테이션 테이블, 페이지 테이블 등을 보관한다. |
| 할당된 자원 정보 | 프로세스를 실행하기 위해 사용되는 입출력 자원이나 오픈 파일 등에 대한 정보이다. |
| 계정 정보 | 계정 번호, CPU 할당 시간, CPU 사용 시간 등이다. |
| 부모 프로세스 구분자 | 현재 프로세스의 부모 프로세스를 가리키는 PPID(Parent PID)가 저장된다. |
| 자식 프로세스 구분자 | 현재 프로세스의 자식 프로세스를 가리키는 CPID(Child PID)가 저장된다. |

### 컨텍스트 스위치(문맥 교환)

한 프로세스에서 다른 프로세스로 CPU 제어권을 넘기는 것이다. 컨텍스트 스위치를 할 때 이전의 프로세스 상태를 PCB에 저장하여 보관하고, 새로운 프로세스의 PCB를 읽어서 보관된 상태를 복구한다.

# 프로세스의 연산

## 프로세스의 생성

### fork() 시스템 호출

실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수이다. 이 함수를 사용하면 실행 중인 프로세스와 똑같은 프로세스가 하나 더 만들어진다.

### fork() 시스템 호출의 동작 과정

fork 시스템 호출을 하면 PCB를 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어진다.

복사되지 않고 새롭게 생기는 부분은 다음과 같다.

- PID(프로세스 구분자)
- 메모리 관련 정보: 부모 프로세스와 자식 프로세스가 차지하고 있는 메모리의 위치가 다르기 때문이다.
- PPID와 CPID: 부모 프로세스의 부모는 존재하지 않거나, 우리가 모르는 다른 프로세스일 것이며, 자식 프로세스의 부모는 부모 프로세스일 것이다. 또한, 부모 프로세스의 자식은 자식 프로세스이지만, 자식 프로세스의 자식은 fork 직후에는 없으므로 CPID는 -1이 된다.

fork 시스템 호출이 성공할 경우: 자식 프로세스가 만들어진다. 부모 프로세스에서는 자식 프로세스의 프로세스 ID가 반환된다. 자식 프로세스에서는 0을 반환한다.

fork 시스템 호출이 실패할 경우: 자식 프로세스가 만들어지지 않는다. 부모 프로세스에서는 -1이 반환된다.

```c
#include <stdio.h>
#include <unistd.h>

void main()
{
	int pid = 0;

	pid = fork();

	if (pid < 0) // fork 호출 실패
	{
		printf("Error");
	}
	else if (pid == 0) // 자식 프로세스
	{
		printf("Child");
	}
	else // 부모 프로세스
	{
		printf("Parent");
	}
}
```

위 main 함수를 실행할 경우, Child와 Parent 모두 1번씩 출력된다. 그러나 부모 프로세스와 자식 프로세스가 서로 독립적이기 때문에 둘 중 어느 것이 먼저 출력될지는 알 수 없다.

만약 fork문 이전에 파일을 열거나 변수를 선언하면 이것이 모두 자식 프로세스에게 상속된다.

### fork() 시스템 호출의 장점

- 하드디스크로부터 프로그램을 새로 가져오지 않고 기존 메모리에서 복사하기 때문에 **자식 프로세스의 생성 속도가 빠르다.** 예를 들어, 크롬에서 [Ctrl + N] 키를 눌렀을 때 생성되는 두 번째 페이지의 생성 속도가 첫 번째 페이지의 생성 속도보다 빠르다.
- **부모 프로세스가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속할 수 있다.** 예를 들어, 부모 프로세스가 파일 A를 사용하기 위해 초기화했다면, 자식 프로세스는 파일 A를 따로 초기화하지 않고 바로 사용할 수 있다.
- 시스템 관리를 효율적으로 할 수 있다. 프로세스를 종료하면 사용하던 메모리 영역, 파일, 하드웨어를 정리해야 한다. 부모 프로세스와 자식 프로세스가 CPID와 PPID로 연결되어 있으면, 자식 프로세스를 종료할 경우 자식이 사용하던 자원을 부모 프로세스가 정리할 수 있어 시스템을 효율적으로 관리할 수 있다.

### fork() 시스템 호출의 예

- 워드 프로세서 프로그램을 켠 상태에서 같은 워드 프로세서 프로그램을 하나 더 실행할 경우
- 크롬 브라우저에서 [Ctrl+N] 키를 누를 경우

## 프로세스의 복사

### exec() 시스템 호출

프로세스는 그대로 둔 채 내용만 바꾸는 시스템 호출이다. exec() 시스템 호출을 하면 현재의 프로세스가 완전히 다른 프로세스로 전환된다. 이 시스템 호출은 이미 만들어진 프로세스의 구조를 재활용하기 위해 사용한다. 이것은 이미 만들어진 PCB, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있다는 이야기이다.

### exec() 시스템 호출의 동작 과정

exec 시스템 호출을 하면 **코드 영역에 있는 기존의 내용이 새로운 코드로 바뀌고, 데이터 영역이 새로운 데이터로 채워지고, 스택 영역이 리셋된다.** 또한 **PCB의 내용 중 PID, PPID, CPID만 남겨두고 나머지 내용을 새로운 것으로 바꾼다.**

exec 시스템 호출을 사용하여 새로운 프로세스로 전환하더라도 PCB의 PID, PPID, CPID는 변경되지 않기 때문에, 프로세스가 종료된 후 부모 프로세스로 돌아올 수 있다.

## 프로세스의 계층 구조

### 유닉스의 프로세스 계층 구조

운영체제는 프로세스를 효율적으로 관리하기 위해 init 프로세스를 만든 후 전체 프로세스의 출발점으로 한다. init 프로세스에서 fork와 exec 시스템 호출을 통해 자식 프로세스를 만든다. 결국, 운영체제에 있는 init을 제외한 모든 프로세스는 모두 init 프로세스의 자식이 된다.

### 프로세스 계층 구조의 장점

동시에 여러 작업을 처리하고, 종료된 프로세스의 자원을 회수하기에 유용하다.

- 여러 작업의 동시 처리: 사용자 여러 명이 login 프로세스에 접근한다면, fork를 통해 여러 개의 login 프로세스를 만들어 각 사용자에게 나눠준다. 사용자가 로그인에 성공하면, 새로운 shell 프로세스를 만드는 대신 exec를 활용하여 login 프로세스의 구조를 재활용한다. 이렇게 하면 자원을 효율적으로 사용할 수 있고, 기존의 부모-자식 관계를 유지할 수도 있다.
- 용이한 자원 회수: 프로세스를 부모-자식 관계로 만들면, 프로세스가 작업을 마친 후 그 프로세스가 사용하던 자원을 그 프로세스의 부모 프로세스가 회수할 수 있다. 이렇게 하면 운영체제가 모든 자원을 직접 회수하는, 복잡한 일을 할 필요가 없다.

### 고아 프로세스

부모 프로세스가 자식 프로세스보다 먼저 종료되거나, 자식 프로세스가 비정상적으로 종료되어 부모 프로세스가 자식 프로세스의 종료 사실을 알지 못하는 경우가 있다. 이런 경우, 자식 프로세스가 종료되지 않거나, 종료되었는데도 사용하던 자원을 회수하지 못한다.

고아 프로세스는 부모 프로세스가 자식 프로세스보다 먼저 죽는 경우에 발생한다. 좀비 프로세스는 자식 프로세스가 종료되었음에도 부모 프로세스가 자원 회수를 하지 않을 때 발생한다.

컴퓨터에 이러한 프로세스가 많아지면 자원이 낭비되어 효율적인 운영에 방해된다. 따라서 운영체제는 반환되지 못한 자원을 주기적으로 회수한다.

## exit()와 wait() 시스템 호출


### exit() 시스템 호출

자식 프로세스가 끝났음을 부모 프로세스에게 알려주기 위해 사용한다. 반환 값이 0이면 정상 종료, -1이면 비정상 종료이다. fork() 시스템 호출 이후에는 자식 프로세스와 부모 프로세스 중 무엇이 먼저 실행될지 알 수 없다.

### wait() 시스템 호출

exit() 시스템 호출만 사용하면, 부모 프로세스가 자식 프로세스의 exit() 반환 값을 받지 못하고 다음 문장을 실행하기 때문에, 먼저 종료될 수 있다. 자식의 자원을 정리해야 할 부모 프로세스가 먼저 종료되면 자식 프로세스와 exit() 시스템 호출은 돌아갈 곳이 없어진다. 이렇게 생기는 프로세스가 고아 프로세스이다. 이러한 경우 고아 프로세스가 차지한 자원은 이후 운영체제가 회수하겠지만, 고아 프로세스가 많아질수록 시스템의 자원 낭비가 심해진다.

wait() 시스템 호출은 부모 프로세스가 자식 프로세스가 끝날 때까지 기다렸다가 자식 프로세스가 종료되고 나서야 비로소 다음 문장을 실행한다. 이러한 특징으로 인해, 이 시스템 호출은 부모-자식 프로세스 간의 동기화에도 사용된다.

## 프로세스의 동적 할당 영역

스택 영역과 힙 영역은 프로세스가 실행되는 동안 만들어지는 영역이다. 또한, 이 영역들은 동적 할당 영역이다.

### 스택 영역

- 호출한 함수가 종료되면, 함수를 호출하기 전 코드로 되돌아와야 한다. 그리고 되돌아올 메모리의 주소를 스택에 저장한다. 즉, 함수 호출을 할 때 스택에 push가 일어나고, 복귀할 때 pop이 일어나는 것이다.
- 함수에서 사용하는 지역 변수는 함수가 호출될 때만 사용되다가 함수가 종료되면 사용한 공간을 반환해야 한다. 이러한 지역 변수를 저장할 때 스택이 사용된다. 즉, 함수가 호출될 때 그 함수에 있는 지역 변수를 스택에 push하고, 함수가 종료될 때 그 지역 변수들을 스택에서 pop한다.
- 스레드가 작동하는 동안 추가되거나 삭제된다.

### 힙 영역

- 동적으로 할당되는 변수 영역으로, 프로그램이 실행되는 동안 할당된다.
- 사용자의 프로그래밍에 따라, 필요할 때만 메모리를 사용하다가 필요 없어지면 반환할 수 있으므로, 힙 영역을 잘 활용하면 메모리 관리를 효율적으로 할 수 있다.
- 메모리의 낮은 주소에서 높은 주소의 영역으로 할당된다.

<aside>
💡 **데이터 영역 VS 힙 영역**
데이터 영역: 프로그램이 시작될 때 메모리가 할당된다. 프로그램이 종료될 때 메모리가 소멸된다.
힙 영역: 프로그램 실행 도중 메모리가 할당되고 반환된다.
데이터 영역에, 무작정 큰 공간을 배열로 확보하면 메모리가 낭비되고 시스템이 느려진다. 하지만, 힙 영역을 통해 배열의 크기를 실행 도중 확보하면 필요할 때 원하는 크기만큼의 메모리를 사용할 수 있다. 이것은 배열에게 메모리 공간을 할당하기 이전과 반환된 후에는 메모리 공간을 차지하지 않기 때문에 가능하다.

</aside>

# 스레드

프로세스의 작업 과정은 다음과 같다.

1. 운영체제는 코드와 데이터를 메모리에 가져오고, PCB를 생성하고, 작업에 필요한 메모리 영역을 확보하여 프로세스를 생성한 뒤, 준비 큐에 삽입한다. 
2. CPU 스케줄러가 dispatch(PID)를 실행한다. 이 과정에서 CPU 스케줄러가 프로세스가 해야 할 일을 CPU에게 전달하고 실제 작업은 CPU가 수행하게 된다. 이 때, CPU에게 전달하는 일 하나하나가 스레드이다. 그러므로 **CPU가 처리하는 작업의 단위는 프로세스로부터 전달받은 스레드**이다. 즉, 운영체제 입장에서의 작업 단위는 프로세스이고, CPU 입장에서의 작업 단위는 스레드이다.

결국, 스레드는 **CPU가 처리하는 작업의 단위**이며, **한 프로세스 내에서 실행되는 동작의 단위**이다.

## 스레드 관련 용어

### 멀티태스킹

여러 작업이 CPU를 나눠 사용하는 것을 말한다. 이는 운영체제가 여러 스레드에 시간을 잘게 나누어 주는 시분할 시스템으로 구현된다. 시분할 시스템에서 운영체제가 CPU에 전달하는 작업은 스레드 단위이다.

### 멀티프로세싱

프로세서를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경이다. 하나의 컴퓨터에 여러 개의 CPU를 두거나 하나의 CPU에 여러 개의 프로세서를 두는 방식으로 구현된다. 네트워크로 연결된 여러 컴퓨터에 스레드를 나누어 협업하는 분산 시스템도 멀티프로세싱의 일종이다.

### CPU 멀티스레드

한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법이다.

## 프로세스 VS 스레드

|  | 프로세스 | 스레드 |
| --- | --- | --- |
| 단위 | 운영체제로부터 자원을 할당 받는 “작업의 단위” | 프로세스 내에서 프로세스가 할당 받은 자원을 이용하는 “실행의 단위” |
| 연결 강도 | 약하게 연결 | 프로세스 내부에서 서로 강하게 연결 |
| 메모리 공유 | 각각 별개의 메모리를 차지 | 프로세스 내의 메모리를 공유하여 사용 |
| 통신 방식 | 프로세스 간 통신(IPC) | 스레드 간 변수와 파일 공유, 전역 변수나 함수 호출 사용 |

## 멀티스레드

프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법이다.

### 멀티스레드의 구조

기존에는 여러 개의 작업을 동시에 처리하기 위해 fork 시스템 호출과 exec 시스템 호출을 같이 사용하는 방식을 택했다. 그러나 fork 시스템 호출은 프로세스를 복사하는 것이므로, 이 경우 코드 영역과 데이터 영역의 일부가 메모리에 중복되어 존재한다. 이는 부모-자식 관계이기는 하지만 서로 독립적인 프로세스이므로 일어나는 메모리 낭비 현상이다. 스레드는 이러한 멀티태스킹의 낭비 요소를 제거하기 위해 사용한다.

과거에는 프로세스 하나에 스레드 하나였기 때문에 여러 작업을 하기 위해서는 fork 시스템 호출을 통해 프로세스 여러 개를 만들어야 했다. 그러나 오늘날에는 프로세스 하나에 스레드 여러 개를 만들 수 있어 보다 효율적인 방식으로 운영할 수 있다.

![멀티스레드의 구조](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/349700dd-5769-4e8b-9a4d-c2fd3e31407d/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230107%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230107T145114Z&X-Amz-Expires=86400&X-Amz-Signature=1fa2898b9ca2bb64cef37d80ab7fb5f4a1e0ba369986f550c0dac3de9709d4cb&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22%25EB%25A9%2580%25ED%258B%25B0%25EC%258A%25A4%25EB%25A0%2588%25EB%2593%259C.png%22&x-id=GetObject)

멀티스레드의 구조

### 멀티스레드의 예

다음은 자바 스레드 코드이다. 자바의 경우 프로그래밍 언어 자체에서 스레드를 제공하며, 스레드 클래스의 run() 메서드를 오버라이딩하여 사용한다.

```java
class ThreadTest extends Thread {
	public void run() {
		for (int i = 0; i < 100; i++) {
			System.out.println("ThreadTest");
		}		
	}
}

public class Main {
	public static void main(String[] args) {
		ThreadTest test = new ThreadTest();
		test.start();
		for (int i = 0; i < 100; i++) {
			System.out.println("Main");
		}			
	}
}
```

main 메서드를 실행하면, “ThreadTest”와 “Main”을 각각 100번씩 출력한다. 이 코드가 스레드를 사용하지 않은 코드라면, “Main”이 100번 출력된 후 “ThreadTest”가 100번 출력될 것이다. 그러나 이 코드는 스레드 2개가 독립적으로 시행되기 때문에 “ThreadTest”와 “Main”이 섞여서 출력된다.

이러한 출력 결과는 fork로도 구현할 수 있다. 하지만 fork로 구현 시에는 PCB, 코드, 데이터가 모두 2배가 되어 메모리와 소요 시간 측면에서 비효율적이다.

그 외 예시로, 인터넷 익스플로러의 각 탭은 스레드로 이루어져 있다.

### 멀티스레드의 장점

- 응답성 향상: 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빠르게 응답할 수 있다.
- 자원 공유: 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원활하게 진행할 수 있다.
- 효율성 향상: 불필요한 자원의 중복을 막아 시스템의 효율이 향상된다. 한 프로세스 내의 메모리 영역 중 정적 영역을 공유하기 때문에 메모리 낭비가 적다.
- 다중 CPU 지원: 다중 CPU가 멀티스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스의 처리 시간이 단축된다.
- 시간 단축: 컨텍스트 스위칭 시 캐시 메모리를 초기화할 필요가 없기 때문에 컨텍스트 스위칭을 하는 시간이 단축된다. 즉, 프로세스 간의 통신보다 통신 비용이 적기 때문에 통신으로 인한 오버헤드가 적다. 또한, 프로세스 생성, 자원 할당 등의 시스템 콜을 생략할 수 있어 자원을 효율적으로 관리할 수 있다.

### 멀티스레드의 단점

- 한 스레드에 문제가 생기면 같은 프로세스 내의 다른 스레드에도 영향을 미친다.
- 각각의 스레드 중 어떤 것이 먼저 실행될지 그 순서를 알 수 없다. 그러므로 주의 깊은 설계가 필요하다.
- 디버깅이 까다롭다.

<aside>
💡 **멀티 프로세스와 멀티 스레드, 무엇을 사용하면 좋을까?**
메모리 구분이 필요할 때는 멀티 프로세스가 유리하다.
컨텍스트 스위칭이 자주 일어나고 메모리 공유가 빈번한 경우, 자원을 효율적으로 사용해야 하는 경우에는 멀티 스레드가 유리하다.

</aside>

### 멀티스레드 모델

스레드에는 커널이 직접 생성하고 관리하는 커널 스레드와 라이브러리로 구현하는 사용자 스레드가 있다.

### 커널 스레드

커널이 멀티스레드를 지원하는 방식이다. 하나의 사용자 스레드가 하나의 커널 스레드와 연결되기 때문에, 1 to 1 모델이라고 부른다.

**장점**

각 스레드를 독립적으로 스케줄링할 수 있어, 특정 사용자 스레드가 대기 상태에 들어가도 다른 사용자 스레드는 작업을 계속할 수 있다.

커널 레벨에서 모든 작업을 지원하기 때문에, 여러 개의 프로세서를 동시에 사용할 수 있다.

커널이 제공하는 보호 기능 등의 커널 제공 기능을 사용할 수 있으며, 안정적으로 작동한다.

**단점**

컨텍스트 스위칭 시 오버헤드가 크기 때문에 속도가 느리다.

### 사용자 스레드

운영체제가 멀티스레드를 지원하지 않을 때 사용하는 방법으로, 운영체제가 멀티스레드를 지원하지 않던 초기의 스레드 시스템에서 이용되었다. 관련 라이브러리를 이용하여 스레드를 구현하며, 라이브러리는 커널이 지원하는 스케줄링이나 동기화 같은 기능을 대신 구현해준다. 커널 입장에서 이 스레드는 하나의 프로세스에 불과하다. 사용자 프로세스 내에 여러 개의 사용자 스레드가 존재한다고 해도, 결국 커널의 스레드 하나에 연결되는 것이기 때문에, 1 to N 모델이라고 부른다.

커널에서 컨텍스트 스위칭이 일어나는 이유는, 시간을 분할하여 각 스레드를 실행해야 하기 때문이다. 그러므로, 라이브러리가 직접 스케줄링을 하고 작업에 필요한 정보를 처리하는 형태인 사용자 스레드는 컨텍스트 스위칭이 필요 없다. 

**장점**

사용자 스레드에서는 컨텍스트 스위칭이 일어나지 않기 때문에 속도가 빠르다.

**단점**

1 to N 모델이기 때문에, 하나의 사용자 스레드가 입출력 작업을 위한 대기 상태에 들어가면, 같은 커널 스레드에 속한 모든 사용자 스레드가 같이 대기해야 한다.

한 프로세스의 타임 슬라이스를 여러 스레드가 공유하기 때문에, 여러 개의 프로세서를 동시에 사용할 수 없다.

공유 변수를 보호하는 장치를 직접 구현해야 하므로 보안에 취약하다.

### 멀티레벨 스레드

사용자 스레드와 커널 스레드를 혼합한 방식이다. M to N 모델이라고 부른다. 커널 스레드의 개수가 사용자 스레드의 개수보다 적거나 같다. 커널 스레드를 함께 사용하기 때문에 사용자 스레드보다 유연하게 작업을 처리할 수 있다. 하지만 여전히 컨텍스트 스위칭 시 오버헤드가 있어 사용자 스레드만큼 빠르지는 않다.

빠르게 움직여야 하는 스레드는 사용자 스레드로 작동하고, 안정적으로 움직여야 하는 스레드는 커널 스레드로 작동한다.

### TCB(Thread Control Block)

참고: [https://teraphonia.tistory.com/802](https://teraphonia.tistory.com/802), [https://velog.io/@cchloe2311/운영체제-Context-Switching](https://velog.io/@cchloe2311/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Context-Switching)

컨텍스트 스위칭 진행 중, CPU는 아무런 일도 하지 못하기 때문에 오버헤드가 발생한다. 따라서 이 시간을 최대한 짧게 하는 것이 중요하다. 그래서 기존의 PCB보다 적은 데이터를 갖는 자료구조인 TCB를 사용하게 되었다.

스레드별로 존재하는 자료구조이다. 커널 레벨에서 컨텍스트 스위칭을 할 때 기본 단위가 된다.

같은 프로세스 간 컨텍스트 스위칭을 할 때는 TCB 정보만 저장하면 된다. 그러나, 다른 프로세스 간 컨텍스트 스위칭을 할 때는 PCB, TCB 정보를 모두 저장해야 한다.

![TCB와 PCB의 관계](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/91d8f42e-7dcc-4ab7-a3ca-15a4ab30ebf6/TCB.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230107%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230107T145139Z&X-Amz-Expires=86400&X-Amz-Signature=9eccc26f0c99bc5b6ee30bd9c383c87ea70f8c21da8f38ca5049c44721b8df0a&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22TCB.png%22&x-id=GetObject)

TCB와 PCB의 관계

다음은 TCB에서 가지고 있는 정보이다.

| PCB를 가리키는 포인터 | PCB를 가리키는 포인터를 가진다. |
| --- | --- |
| 스레드 ID
(스레드 식별자) | PCB를 연결하여 준비 상태나 대기 상태의 큐를 구현할 때 사용한다. |
| 스택 포인터 | 프로세스에 있는 스레드의 스택을 가리킨다. |
| 프로그램 카운터(PC) | 다음에 실행할 명령어의 주소를 가리킨다. |
| 스레드 상태 | 준비, 실행, 대기, 완료 등 |
| 각종 레지스터 정보 | 사용하던 레지스터들의 값을 보관한다. |

**질문 목록**

- 같은 프로세스에 속하는 스레드 사이에서 컨텍스트 스위칭이 일어난다고 가정해봅시다.
    - 스레드는 PCB를 갖고 있을까요?
    - 두 스레드의 컨텍스트 스위칭으로 인해 바뀌는 정보에는 무엇이 있을까요?
    - 두 스레드 사이에서 일어나는 컨텍스트 스위칭은, 서로 다른 두 프로세스 사이에서 일어나는 컨텍스트 스위칭에 비해 어떤 장점이 있을까요?
- 프로그램과 프로세스의 차이에 대해 설명해 주세요.
    - 프로세스와 스레드의 차이에 대해 설명해 주세요.
- 계층 구조를 갖는 프로세스가 있다고 가정합시다. 부모 프로세스가 자식 프로세스보다 먼저 죽게 되면 어떤 일이 발생할까요?